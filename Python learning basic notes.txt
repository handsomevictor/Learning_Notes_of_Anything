1.	python的学习
	print("i love you\n" * 8)
	python没有;,这种标点符号！

2.	设计一个小游戏
#coding: gbk
print('-------------我爱鱼c工作室--------------')
temp = input("猜一下小甲鱼现在心里想的是哪个数字:\n")		
guess = int(temp)											//这里将temp强行转化成Int格式
if guess == 8:
    print("卧槽，你是小甲鱼心里蛆虫吗？！")
    print("哼，猜中了也没有奖励！")
else:
    print("猜错啦，小甲鱼现在心里想的是8！")
print("游戏结束，不玩啦~")

3.	BIF = built-in function，内置程序

4.	大小写的变量不一样！

5.	原始字符串：
	str = 'C:\desktop\nuser'	这里打印的话会有转义现象，需要这样：
	str = r'C:\desktop\nuser'	加一个r即可
	#直接敲str的结果是'C:\\desktop\\nuser'
	
	注意：原始字符串在最后是不能加反斜杠的
	
	如果想打印直接换行，可以直接这样：（更快）
	str = """
	我爱你我爱你我爱你
	我爱你我爱你
	我爱你
	我
	"""
	然后输入str就会自动返回'\n我爱你我爱你我爱你\n我爱你我爱你\n我爱你\n我\n'
	这样刚刚好
	
6.	and逻辑操作符，可以连接任意的表达式并且返回一个布尔类型的值。
	or逻辑符，同理
	not逻辑符：取相反布尔类型的值
	
7.	random模块中有一个randint()函数。
	返回一个随机的整数。
	
8.	可以直接这样写数据: a = 1.5e11，就是1.5 * 10 ^ 11
	
	布尔类型是整数！
	你可以这么写：true + true
	true = 1, false = 0
	
	强制转型：int(), float(), str()
	
	int(5.99) = 5
	
	获得关于类型的信息: type(), isinstance()
	
	isinstance()用法：（返回布尔类型）
	a = '我爱你'
	isinstance(a, str)
	这句就会打印true。
	这里各种类型是：int float bool str
	
9.	算数操作符
	a +=
	b *=
	c */
	这样可以，但是a++这样不行
	
	a = b = c = d = 10
	直接方便赋值
	
	%：取余数
	//：取整数
	**：幂
	
	10 // 3.0只要里面有float，则结果是float结果。
	
	8 * -3可以直接写，可以不用加括号在负数这里
	
	幂运算中，幂比它左侧的优先级高，右侧的优先级低
	-3 ** 2，这里输出-9
	
	not逻辑符，取相反的布尔类型的值。
	0认为是false,其他认为是true
	所以not 0 = true
	not 4 = false
	
	3 < 4 < 5
	这样写也是合法的，会自动改写成3 < 4 and 4 < 5
	
	x, y = 4, 5
	
10.	分支语句：
	if, if, if
	if: else:
	if: elif:
	
	三元操作：
	可以这么来写：
	guess = x if x > y else y
	(即当x>y的时候Guess赋值x反之赋值y)
	
11.	assert用法
	比如在你的程序中有x和y了，然后你需要之后使用到x和y，但是你想法是x一定大于y的，那么这个时候就可以加：
	assert x > y
	如果之后报错就会指明是这一点出错了！

12.	while for 循环

	for 目标 in 表达式：
		循环体
	
	比如打印victor但是里面每个字母之间加上一个空格，可以这样：
	f = 'victor'
	for i in f:
		print(i, end = ' ')
		
	number = ['vic', 'grace', 'leeloo']		#创建一个列表
	for each in number:
		print(each, len(each))				#打印了每一个列表中的字符串，加上它的len长度
	
	range()函数
	list(range(5))							#[0, 1, 2, 3, 4]输出结果，从0开始一直到n-1!
	
	for i in range(6):
		print(i)							#这样输出结果是竖着的，如果想要横着，则print(i, end = '')
	
	for i in range(1, 6, 2):				#每个数之间相隔2（这里注意一旦写了第三个数，则意味着这三个参数必须写满）
		print(i)
		
	break：终止当前循环并跳出
	用于while True:的循环中，不然永远也false不了
	
	continue语句：跳出本次循环，进行下一次循环（从头执行循环）

13.	列表
	数组
	
	创建普通列表：number = ['vic', 'grace', 'leeloo']
	输出grace: number[2]
	
	创建混合类型
	mix = [1, '123', [1, 2, 3, 4]]		#里面什么都可以加
	len(mix) = 3
	
	向列表添加元素
	append()
	number.append(123)					#添加到最后
	
	append()每次只能添加一个元素
	extend()添加一个列表（原理是用一个列表去扩展另一个列表，所以添加的也必须是列表）
	
	mix.extend(['阿阿阿', '哦哦哦'])
	但是append([1, 2])这样的话是添加一个元素，这个元素是个列表而已
	len()如果()中是一个单词，则返回单词的字母数量，如果是list，则返回元素数量
	
	insert()可以插入，插第一个位置，则insert(0, '123')

14.	从列表删除元素：
	remove()，括号是参数对象的
    mix = [1, '123', [1, 2, 3, 4]]
    则remove的时候需要mix.remove('123')，括号中是list中的元素
    好处是，你不需要知道remove的元素是第几个，只需要知道在里面即可
    
    del，这不是一个方法而是语句
    del mix[1]
    则第二个元素被remove掉了
    del mix整个全删掉
    
    pop()
    mix.pop()这个是将mix中的最后一个元素删除，并赋值给pop()
    a = mix.pop()
    此时a是原来mix中最后一个元素，且mix中已经删除了最后一个了
    
    也可以加入参数
    mix.pop(1)
    则自动返回第二个元素并且删除第二个元素
    
    列表切片：slice()，一次性获取多个元素
    mix[1: 3]
    原列表没有任何更改
    mix[ :3] = mix[0: 3]
    如果要复制一份列表，则a = mix[:]   中间这个:绝对不能省！
    
    
    list1 = [123]
    list2 = [234]
    这里list1 < list2，因为第一个数要小
    list1 + list2，这样类似extend的连接操作
    但是这个加号两边的对象必须是同一个类型的！
    
    list1 * 3，就是复制了3次
    
    123 in list1，这句话会返回True，因为123在list1中
    234 not in list1, True
    
    list3 = [1, 2, [1, 2, 3, 4, 5]]
    如果要找5这个数，则可以list3[2][4]连用两个中括号！
    
    list3.count(123)    表示返回123在list3中的次数
    list3.index(123)    表示返回123在list中第一次出现的位置
    list3.index(123, 4, 7)  表示返回123在list3中第4-7位置中出现的位置（因为可能重复很多次）
    
    reverse将整个列表反转
    list3.reverse()
    
    sort()用指定的方法对list排序，默认是从小到大
    list3.sort()    从小到大
    从大到小：list3.sort().reverse()
    或者list3.sort(reverse = True)
    
    重要！
    以后在复制list的时候，一定要用a = list3[:]的方式！因为如果直接a = list3的话，list3改变了a也跟着改变！
    a = list3这样只是相当于增加了一个标签而已，不要这样做
    
    list3[1: 3]这是获取了两个值！从第2个开始往后选2个！！！！！！！！！！
    list3[2:]这样从第3个到最后一个（不包括第二个）！！！！！！！！！！！
    list3[: 2]这样是从0到第2个！！！！！！！！！！！！！！！！！！！！！！
    
15. 元组：不可改变的
    列表：可以任意改变里面的元素
    tuple = (1, 2, 3, 4, 5, 6, 7, 8)
    这就是元组
    tuple[2] = 3
    
    元组拷贝一样tuple[:]
    
    temp = (1)
    这样创建的还是一个int
    temp = 1, 2, 3, 4
    这样type(temp)创建了一个tuple元组了
    如果只要创建一个1个数字的元组，则需要：
    temp = (1,)     或者temp = 1,
    这个逗号不能少！
    
    8 * (8,) = (8, 8, 8, 8, 8, 8, 8, 8) 是重复的意思
    
    
    更改元组：
    比如添加一个元素
    temp = ('victor', 'grace', 'leeloo')
    在第二个中间插入lee，这样：
    temp = temp[: 1] + ('lee',) + temp[1:]     这里的lee后面必须有,！！
    
    del temp直接全部删了，不推荐，因为python会自动回收，与java一样
   
16.	字符串的方法
	字符串改为大写：
	
	str = 'lizhen ning'
	str.capitalize()
	只是将这个字符串的第一个字符改为大写
	
	str.casefold()
	全部改成小写，返回新的字符串，之前的字符串没有改变
	与lower()的区别：
	lower函数只支持ascill表中的字符，而casefold则支持很多不同种类的语言。
	
	str.center(40)
	返回左边右边都有40个空格，然后居中了
	
	str.count(zh)
	查找zh在str中出现的次数
	
	str.endswith('ng')
	检查str是否以ng结束，是就返回True
	注意！还可以加上范围！
	str1 = 'lizhen ning'
	str1.endswith('h',0,4)
	返回True，也就是说是0-4个字符的位置中最后一个字符（这里似乎不用n-1了）
	单独一个参数的话：
	str1.endswith('h',4)则是第4个之后到末尾的最后一个字符
	
	str.startswith()
	同理
	
	str.find('zh')
	str.find('', 1, 8)（可加范围参数）
	如果能找到就返回下标（从0开始），如果找不到就返回-1
	
	str.index('zh', 1, 9)（可加范围参数）
	结果跟find一样，但是如果找不到会报错，而不是返回-1
	
	str.isalnum()		至少一个字符并且所有都是数字或者英文字母，返回True
	str.isalpha()		字符串中至少有一个字符并且全都是英文字母返回True
	str.isnumeric()		字符串中只包含数字字符，返回True
	
	str.isdecimal()		里面全都是十进制数字返回True
	
		区分：
		isdigit()
		True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字
		False: 汉字数字
		Error: 无

		isdecimal()
		True: Unicode数字，，全角数字（双字节）
		False: 罗马数字，汉字数字
		Error: byte数字（单字节）

		isnumeric()
		True: Unicode数字，全角数字（双字节），罗马数字，汉字数字
		False: 无
		Error: byte数字（单字节）
		
		结论：以后最好只用isnumeric就行了。。
		
	str.islower()
	如果str中包含英文并且全都是小写则返回True
	
	str.isspace()
	如果只包含空格，则返回True
	
	str.istitle()
	str中如果每个单词首字母都大写其他都小写则返回True
	
	str.isupper()
	所有的字符都是大写的返回True
	
	str = 'l love you'
	str.join('abc') 返回 'al love youbl love youc' #a b c插入进去
	
	str.lower()
	所有大写字母转为小写
	
	str.upper()
	转为大写
	
	str.lstrip()
	去掉字符串所有左边的空格
	
	str.rstrip()
	去掉字符串所有末尾的空格
	
	str.partition(sub)
	这个挺有用的，可以直接分离字符串变成包含3元素的元组
	str = 'please dont do that'
	str.partition('dont')
	结果是：
	('please ', 'dont', ' do that')
	（有重复出现的只区分第一个）
	
	str.replace('old', 'new', [count])
	str = 'abcccdeff'
	str.replace('c', 'x') = 'abxxxdeff'
	str.replace('c', 'x', 2) = 'abxxcdeff'	#只将前两个c改了
	
	str.rfind(sub)
	类似find()，但是从右边开始找，可以加范围参数
	
	str.rindex()
	类似index()，但是从右边开始找，可以加范围参数
	
	str.rpartition()
	类似partition()
	
	str.split()
	不带参数默认分割空格
	类似partition，但用的更广！
	str = 'abcccddefcc111c1'
	str.split('c') = ['ab', '', '', 'ddef', '', '111', '1']
	自动生成数列，并且将c抹去，如果连着两个c则生成''
	str.split('c', 2) = ['ab', '', 'cddefcc111c1']
	只把前两个c给分割开了
	
	str.strip()
	把前后的空格都删掉
	str = 's11ssio ooiuss9s'
	str.strip('s') = '11ssio ooiuss9'
	则仅把前后的s给去掉，加了s开头如果还是空格就不再删除了
	
	str.swapcase()
	把大小写反过来
	
	str.title()
	str中所有单词的开头变成大写
	
	str.translate()
	str = 'ssbbaabbfutzss3e'
	str.translate(str.maketrans('s', 'b')) = 'bbbbaabbfutzbb3e'
	这里把所有s换成了b，是其中一种用法
	单独返回str.maketrans('s', 'b') = {115: 98}
	ASCII编码
	
	zfill(width)
	str = 'ssbbaabbfutzss3e'
	len(str) = 16
	str.zfill(20) = '0000ssbbaabbfutzss3e'
	前面填充4个0
	#这个可以用来整理参差不齐的数据，转化为0之后再切片或者转成空格即可
	
17.	字符串的格式化：按照统一的规格去输出字符串
	（比如不同进制）
	
	format函数
	1.位置函数
		a = "{0} love {1} {2}"
		a.format("I", "grace", "very much") = 'I love grace very much'
		
	2.关键字参数
		x = "{a} love {b} {c}"
		x.format(a = "I", b = "grace", c = "very much") = 'I love grace very much'
	也可以混合着用，x = "{0} love {b} {c}"，但是数字必须在前面
	
	四舍五入定点数
	'{0:.1f}{1}'.format(27.789, "GB") = '27.8GB'
	冒号后的.1表示四舍五入到小数点后1位，2就是两位
	
18.	字符串操作符
	%c:格式化字符及其ASCII码
	'%c' %97 = 'a'
	'%c%c%c' %(97, 98, 99) = 'abc'
	'%c %c%c' %(97, 98, 99) = 'a bc'
	其实就是97 98 99按照'%c'排列的方法合并到''里面去
	多个数必须加括号
	
	'%s' %'i love you' = 'i love you'
	'abc%s' %'i love you' = 'abci love you'
	本质上就是替换的过程
	
	%d表示数字
	'%d + %d = %d' %(4, 5, 6) = '4 + 5 = 6'
	只是做了个替换而已
	
	'%f' %27.878 = '27.878000'
	默认会精确到六位数
	
	'%e' %27.878 = '2.787800e+01'
	
	m.n这个很重要！
	'%5.1f' %27.46 = ' 27.5'
	5表示整个字符串最小宽度是5，.1表示四舍五入到小数点后1位
	'%6.2f' %27.4665 = ' 27.47'
	
	加上-表示左对齐
	'%-10d' %27.787 = '27        '
	'%10d' %27.787 = '        27'
	
	需要数字前面显示正负号的话，+即可
	'%+4d' %28.3 = ' +28'
	
	前面加上0的话就意味着前面的空格用0填充
	'%010d' %23.4 = '0000000023'
	
19.	转义字符
	单引号\'
	同理：\"
	\n换行
	\t = tab
	\v纵向制表符
	\r = enter
	\f 换页符
	\0 表示空字符
	
20.	列表，元组，字符串
	list()生成列表
	a = list()
	那么a = []
	
	b = 'i love you'
	b = list(b)
	b = ['i', ' ', 'l', 'o', 'v', 'e', ' ', 'y', 'o', 'u']
	把字符串列表了
	
	元组也可以通过list转化为list
	c = (1, 2, 3, 4, 5)
	c = list(c)
	c = [1, 2, 3, 4, 5]
	
	d = [1, 2, 3, 4, 5]
	d = tuple(d)		#转化为元组
	d = (1, 2, 3, 4, 5)
	
	str转化为字符串
	len(d) = 5	#5个元素
	
	max()
	返回一组数最大值，或者一个字符数组的最大ASCII码的字母，比如max(b) = v
	这里注意，单独的一个字符串也可以max min!
	比如
	a = '182848301'
	max(a) = 8
	
	min()
	同理
	
	使用max min的话数据类型必须统一！不能既有数字又有字符串的
	
	sum()
	a = [12, 23, 45, 67]
	sum(a, 8) = a里面的和加上8
	
	sorted()
	默认从小到大排
	list(reversed(a))
	
	a = [12, 23, 45, 67]
	list(enumerate(a)) = [(0, 12), (1, 23), (2, 45), (3, 67)]
	自动编号
	
	a = [12, 23, 45, 67, 999, 1298]
	b = [1, 2, 3, 4, 5, 7]
	list(zip(a, b))
	#如果直接输出zip(a, b)会得到<zip object at 0x0000019DF9CAEE88>，需要用list的方法来转变
	list(zip(a, b)) = [(12, 1), (23, 2), (45, 3), (67, 4), (999, 5), (1298, 7)]
	#会逐一配对，多余的数字不再管
	
21.	函数
	切割方法
	定义函数一定要有小括号
def Myfirstfunction():
	print('this is my first function')
	
def Mysecondfunction(name):
	print(name + 'i love you')
	
	函数的返回值return
def Mythirdfunction(a, b):
	return a + b
	用了return的话是可以直接赋值的，比如axe = Mythirdfunction(1, 4)
	
	形参:parameter
	实参:argument
	
def Mythirdfunction(a, b):
	'i love aaaa'	#这个是文档
	return a + b	
	这里定义了一个字符串语句，想调用文档的话Mythirdfunction.__doc__ 会输出 'i love aaaa'
	写这个是为了让别人更好的理解
	
	如果有时候ab在输入的时候忘记顺序了，可以这样：
	Mythirdfunction(b = 456, a = 123)

	默认值参数
def Mythirdfunction(a = 1, b = 4):
	return a + b
	调用的时候可以直接Mythirdfunction
	也可以Mythirdfunction(4)
	这里4就赋值给a了，按顺序来的
	
	收集参数：
	写函数的作者有时候也不知道会有多少个参数的时候可以在参数前面加上*
def test(*params):
	print('参数长度是', len(params))	#这里一定是,隔开！！
	print('第二个参数是', params[1])
	
调用：test('小甲鱼', 123, '888')
	结果：
	参数长度是 3
	第二个参数是 123
	
如果想收集函数和关键词函数同时用，比如def test(*params, key):
	那你在写test()的时候必须是写明key = XXX
	
Python所有函数都有返回值的，就算没有return，也会返回none
def back():
	return [1, 'i lov eyou', 3.14]
	
是可以返回一个数组的
也可以直接return 1, 'i lov eyou', 3.14
这样返回的就是元组了


有一个小点，需要注意：
函数外面赋值的字符，尽量不要跟函数内部的参数名一致，如果一样的话，并不会报错，而是很容易
搞不清楚谁调用了谁，很容易逻辑出错。局部变量和全局变量可以重名，因为在不同的栈当中，但是调用要很小心

可以在函数内部访问全局变量，但是不要试图去修改它！

如果需要在局部地区更改全局变量，则需要加上global关键字
a = 10
def myfun():
	global a		#global关键字
	a = 15
	print(a)
这个时候再myfun()就打印的是a = 15了

22.	闭包的概念：
def funx(x):
	def funy(y):
		return x * y
	return funy			#funy本质是函数，所以funx输出的是函数

调用的话：比如：
i = funx(8)
type(i) = function
i(5) = 40
也可以这么调用：
funx(5)(8) = 40

nonlocal的用法：强制转化成非局部变量
def funx():
	x = 5
	def funy():
		x *= x
		return x
	return funy()		#这里局部变量是不可以改变全局变量的，local variable 'x' referenced before assignment
	
	如果想引用x*=x，则用nonlocal用法
def funx():
	x = 5
	def funy():
	    nonlocal x
		x *= x
		return x
	return funy()	
输出funx() = 25

还有一点，上面的程序funx()中的return funy()和return funy其实都可以，因为return funy的话是返回一个function
而return funy()是将funy()函数中的return x给直接return出来了

23.	lamba函数
	匿名函数
	平面几何的直线方程
	
	g = lambda x: x * 5 + 1
	g(5)就可以直接调用了
	k = lambda x, y: x + y
	k(4, 6)

使用Lambda函数就不用费劲命名了

24.	filter()
	过滤器，可以保留想要的东西
	默认的话，就把任何非true的内容给过滤掉
	比如：
	a = [1, 0, True, False, 1 < 2]
	list(filter(None, a)) = [1, True, True]		#一定要用List来引用！
	
	filter中第一个参数可以设置为过滤的要求
	比如：
	筛选出奇数的过滤器：
def odd(a):
	return a % 2	#这里odd返回为0的是偶数，返回为1的是奇数，1是true，所以可以自动filter选择（也可以加not选偶数）
temp = range(10)	#默认即是list类型，不用再list(temp)
b = filter(odd, temp)
list(b)		#返回结果是：[1, 3, 5, 7, 9]

25.	filter + lambda方便实现删选奇数
	list(filter(lambda x: x % 2, range(10))) = [1, 3, 5, 7, 9]
	偶数的话：
	list(filter(lambda x: not x % 2, range(10))) = [0, 2, 4, 6, 8]
	(因为 not 1 = False, not 0 = True)
	
26. map()
	映射：
	list(map(lambda x: x * 2, range(10))) = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
	每个range(10)中的数据都乘以2输出为list
	
27. 递归：函数调用自己
	python系统默认递归层数是100层，可以手动修改：
	import sys
	sys.setrecursionlimit(1000)
	
	用递归写阶乘：
def quant(x):
	if(x == 1):
		return 1
	else:
		return x * quant(x - 1)
调用的话直接quant(6) = 720
	
	非递归版本：
def quant(x):
	result = x
	for i in range(1, x):
		result *= i
	return result
a = int(input('please input a number'))		#这里int最好加上
b = quant(a)
print("%d 的阶乘是 %d" % (a, b))	#这里中间没有逗号！！

12 的阶乘是 479001600

递归效率比较低

28.	还是递归，做斐波那契
非递归版本：
a = []
def quant(n):
    n1 = 1
    n2 = 1
    n3 = 1
    a.append(n1)
    a.append(n2)
    if n < 1:
        print('ERROR')
        return -1
    while (n - 2) > 0:
        n3 = n1 + n2		#这里仅仅是把每一个值做了交替！
        n1 = n2
        n2 = n3
        n = n - 1
        a.append(n3)
    return n3

result= quant(10)
if result != -1:
    print('一共%d只兔子诞生'%result)

输出结果是：一共55只兔子诞生
a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

递归版本：		#原理是5分为4和3相加，4分为3和2相加
def feb(n):
    if n < 1:
        print("error")
        return -1
    if n == 1 or n == 2:
        return 1
    else:
        return feb(n - 1) + feb(n - 2)

result = feb(10)
print(result)

29.	汉诺塔做递归
b = 0
def hannoi(n, x, y, z):	#xyz是三根针，相当于被移动位，辅助移动位，目标位
	global b
	if n == 1:
		b = b + 1
		print(x, "-->", z)	#一个片，x直接到z
	else:
		b = b + 1
		hannoi(n - 1, x, z, y)	#将前n-1个盘子从x移动到y上
		print(x, "-->", z)		#将最底下的盘子从x移动到z上
		hannoi(n - 1, y, x, z)	#将y上的n-1个盘子移动到z上
a = int(input('请输入层数'))
hannoi(a, "X", "Y", "Z")
打印共执行了多少次，就直接b即可。

30.	字典：
	字典是映射
	一个最基本的调用映射的方法：
	a = ['A', 'B', 'C', 'D']
	b = ['E', 'F', 'H', 'G']
	这两个是互相对应的，所以打印b的G可以用a来这么做：
	print(b[a.index('D')])
	
	用字典的方式解决：
	dic1 = {'A': 'E', 'B': 'F', 'C':'H', 'D':'G'}	#大括号就是字典！有很多键值组和
	print('口号是', dic1['D'])
	
	dict就是字典函数dict(mapping)，注意这里dict的参数只有1个！只能是映射！所以可以将元组伪装成1个参数来赋值进去
	可以这样：
	dic1 = dict(((1, 'A'), (2, 'b'), (3, 'C'), (4, 'D'), (5, 'E')))
	dic1输出是：{1: 'A', 2: 'b', 3: 'C', 4: 'D', 5: 'E'}
	
	也可以这样：
	dic2 = dict(a1 = 'A', a2 = 'B')		#!!!这里一定注意，左边可以是中文，但是一定不能加引号！！这是关键字类型！！
	dic2 = {'a1': 'A', 'a2': 'B'}
	
	dict如果输入了{}里面没有的值，则自动加进去新值，如果输入了原本就有的值，则做一次修改
	dic2 = {'a1': 'A', 'a2': 'B'}
	dic2['c1'] = 123		#这里键值都要加引号，如果是关键字的话。
	dic2['a1'] = 'KKK'
	
	此时dic2 = {'a1': 'KKK', 'a2': 'B', 'c1': 123}
	
31.	字典其他用法：
	fromkeys(S[,V])	#创建s:v，v默认是none
	创建新的字典
	
dic1 = {}
dic1 = dic1.fromkeys((1, 2, 3))	#双括号！#且同时这里一定要赋值更新！不然等下输出dic1的时候还是{}！

dic1 = {1: None, 2: None, 3: None}
这里V只能有一个元素！
比如：
dic1 = {}
dic1 = dic1.fromkeys((1, 2, 3), ('one', 'two', 'three'))
dic1 = {1: ('one', 'two', 'three'), 2: ('one', 'two', 'three'), 3: ('one', 'two', 'three')}

dic1 = {}
dic1.fromkeys(range(10), '赞') = {0: '赞', 1: '赞', 2: '赞', 3: '赞', 4: '赞', 5: '赞', 6: '赞', 7: '赞', 8: '赞', 9: '赞'}

keys代表键，如果想把键都打印出来，则：
for eachkey in dic1.keys():			#.keys()
	print(eachkey)
	
结果：
0
1
2
3
4
5
6
7
8
9

values()代表值，同理：
for eachvalue in dic1.values():
	print(eachvalue)
	
#outcome:	
赞
赞
赞
赞
赞
赞
赞
赞
赞
赞

items()表示项，把每一项都打印出来:
for eachitem in dic1.items():
	print(eachvitem)
结果：
(0, '赞')
(1, '赞')
(2, '赞')
(3, '赞')
(4, '赞')
(5, '赞')
(6, '赞')
(7, '赞')
(8, '赞')
(9, '赞')

dic1[31] = '赞'

get()方法，减少报错，尤其是调用不存在的值的时候
dic1.get(32)这就什么都不会返回，因为32个不存在，print出来时None

也可以返回默认值，比如dic1.get(32, '没有这个数！')

dic1.get(5) = '赞',会返回

更快速的办法判断键是否在字典里面，可以用 
30 in dic1
返回True就是在里面
注意这个in 或者not in不能用于值，只能用于键！


如果需要清空字典，推荐用.clear()而不是直接a = {}
因为如果项目复杂，中间有b = a这种情况，
那么当你a.clear()之后b也会clear掉。但如果仅赋值a = {}
b依然储存了数据。这对隐私数据存储很不好

同理一个copy()方法
a = {1:"A", 2:"B", 3:"C"}
b = a
c = a.copy()
此时通过id()查询一下abc，有：
>>> id(a)
2446169078104
>>> id(b)
2446169078104
>>> id(c)
2446169591880
c是自己复制了一份，所以跟ab没有关系，以后在改变c的话ab不会改变，但是改变b的话a会跟着改变，改变a的话b也会改变！


pop():弹出键的值
popitem():弹出项
a = {1:"A", 2:"B", 3:"C"}
a.pop(2) = 'B'
a = {1: 'A', 3: 'C'}	#B就不见了

pop的话在数组中都是自动弹出最后一个
a = {1:"A", 2:"B", 3:"C"}
a.popitem() = (3, 'C')
a = {1: 'A', 2: 'B'}


a.setdefault('小白', 1)
a = {1: 'A', 2: 'B', '小白': 1}
没有创建的会自动创建。创建了的会更改值。

update()
b = {'小黑': 1, '小白': 2}
a.update(b)
a = {1: 'A', 2: 'B', '小白': 2, '小黑': 1}
相当于列表的extend。


32.	集合：set
	a = {1, 2, 3, 4, 5}
	没有映射的关系的话，用大括号括起来就是集合
	
	集合直接会把重复的元素剔除掉！
	集合没有顺序，不支持索引！
	不能a[2]这样！
	
	set()创建集合
	set1 = set([1, 2, 3, 4, 5, 5, 4])
	set1 = {1, 2, 3, 4, 5}
	
	去除重复元素简单方法：
	num1 = list(set(num1))
	#但是这样是不能保证原来的顺序！！！
	
	集合也可以用in not in来访问
	add(), remove()
	集合只能用add()来添加元素！
	set1.add(123)
	set1.remove(234)
	
	
	不可变集合：frozenset
	a = frozenset([1, 2, 3, 4, 5])
	a.add(11)	#这里会报错，因为不能添加！
	
33.	用python来进行打开文件的操作:
	open()
	不同的打开模式：
	'r':只读方式
	'w':写入文件，会覆盖已存在的文件
	'x':如果文件已经存在，使用此模式打开会发生异常
	'a':以写入模式打开，如果文件存在，则在末尾追加
	'b':二进制模式打开
	't':文本模式打开
	'+':可读写模式，可以添加到其他模式中
	如果打开一个不存在的文件，则必须是w才能创建新文件
	默认是r和t
	
	
	f = open('C:\\Users\\handsomevictor\\Desktop\\股票相关\\2020.8.17.txt')
	这里一定要用引号引起来！！！
	
	文件执行操作：
	f.close()关闭文件
	f.read(size = -1)读取size个字符，当为给定或者size是负数时候，读取剩余所有字符，然后作为字符串返回
	f.readline()以写入模式打开，如果文件存在则在末尾追加写入
	f.write(str)将字符串写入文件
	f.writelines(seq)像文件写入字符串序列seq
	f.seek(offset, from)在文件中移动指针，从from(0代表起始位置，1代表当前位置，2代表文件末尾)偏移offset个字节
	f.tell()返回当前在文件中的位置
	
	注意，使用完文件要记住close()不然可能不会自动保存
	
	f = open('C:\\Users\\handsomevictor\\Desktop\\股票相关\\2020.8.17.txt', 'r',encoding='UTF-8')
	注意实际操作中，一定要加'r'和后面的UTF-8，不然中文的显示不出来
	
	注意！这是我一点一点摸索的！
	f.read()完了之后，指针是会到最后一个位置的！
	f.的这以上的所有操作，只要涉及读取，读完之后都会改变指针位置的。
	所以需要将指针复位。
	f.seek(0,0)，这样就从0点开始复位了。
	想知道现在指针在哪里，直接就f.tell()即可
	
	a = list(f)的话，会自动的把每一行转变为一个数组中的元素
	但是要注意，这里list(f)只会从指针在f中的位置开始到结尾。
	
	需要将list中的打印出来，效率高：
	for each_line in f:
		print(each_line)
	（这样会原本换行的会又换一次行）
	
	！！！！！！！！！！！！！！！！！！！
	文件的写入：
	确保已经是'w'或者'a'
	直接f.write('\nwerwerwer')就会直接添加到末尾
	但是要注意，这个时候一定要f.close()
	否则不会直接保存，不能直接f.read()
	另外，下一次f.read()之前，一定要确保open的时候里面是a+或者w+，不然是不可以read的！！！！！
	
34.	将文件中的数据进行分割等。
	比如有txt文件是这样内容：
A:the first line
B:the second line
A:the third line
-----------
C:the fourth lineasdasdasd
-------
D:i dont like yuou
E:my stock price is 12000
	
	按照---进行分割，然后单独储存成txt
	
	这是个失败的举例。。详见66.py
	
35.	模块
	Operating System模块
	这个是让py在不同的环境中都能适用的一个方法
	
>>> import os		#先import
>>> os.getcwd()
'C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\Python37_64'
	返回当前工作目录，py的安装地方
	
os.chdir('C:\\Users\\handsomevictor\\Desktop\\python IDLE')	改变当前目录
os.listdir()		列举所在路径中的文件名，列举之后是以数组的形式存在！！
os.mkdir('C:\\Users\\handsomevictor\\Desktop\\python IDLE\\A')				创建文件夹！只能是文件夹，不能是文件！
os.remove('C:\\Users\\handsomevictor\\Desktop\\python IDLE\\A\\a.txt')		删除文件！不能是目录！！
os.rmdir('C:\\Users\\handsomevictor\\Desktop\\python IDLE\\A')				删除目录！如果目录中有内容则无法直接删除全部目录
os.removedirs()	递归删除目录，从子目录到父目录尝试逐层删除，除非遇到非空抛出异常
os.rename(old, new)	重新命名

os.system('cmd')	os.system()括号里加上windows shell里面的命令即可，比如mspaint，calc

os.curdir	这不是函数，这个指代当前目录，相当于'.'
用法：获取当前目录下的文件内容：os.listdir(os.curdir) (这个等同于os.listdir('.')，但是更规范，不容易错
os.pardir	指代上一级目录，相当于'..'


os.path方法，里面有挺多平常用不到的但是在大规模数据里面能用到的方法。。
os.path.basename(r'C:\Users\handsomevictor\Desktop\python IDLE\第一个小游戏.py')	#返回的是去掉路径之后的纯文件名
	这个返回的就是：'第一个小游戏.py'
os.path.dirname(r'C:\Users\handsomevictor\Desktop\python IDLE\第一个小游戏.py')		#返回的是路径名，去掉文件名
	这个返回的就是：'C:\\Users\\handsomevictor\\Desktop\\python IDLE'
	这个返回的路径可以配合listdir来直接提取当前目录下其他文件
	
os.path.join()	#是组成路径的方法，但是如果要加上盘符，则需要加\\，比如：
	os.path.join('C:\\', 'A', 'B') = 'C:\\A\\B'
	os.path.join('A', 'B', 'C') = 'A\\B\\C'
	
os.path.split('')	#这个split是会将路径分成路径和文件名两部分的，但是注意如果只是纯路径，则也会将最后一部分文件名单独分割出来
	os.path.split('C:\\A\\B\\C\\D\\sexy.avi') = ('C:\\A\\B\\C\\D', 'sexy.avi')
	os.path.split('C:\\A\\B\\C\\D') = ('C:\\A\\B\\C', 'D')
	os.path.splitext('C:\\A\\B\\C\\D\\sexy.avi') = ('C:\\A\\B\\C\\D\\sexy', '.avi')
		这里用到搜索文件类型里面还是很好用的，比如a = list(os.path.splitext()), b[1]就能返回这个后缀名
os.path.getsize(file)	#返回尺寸
os.path.getatime(file)	#返回这个文件的最近访问时间
os.path.getctime(file)	#返回这个文件的最近创建时间
os.path.getmtime(file)	#返回这个文件的最近修改时间
	这三个可用time模块的gmtime()或者localtime()来换算！gm是返回格林尼治时间，localtime是返回当地时间！
	import time
	a = time.gmtime(os.path.getatime())
		会返回一个这种玩意：time.struct_time(tm_year=2020, tm_mon=8, tm_mday=10, tm_hour=4, tm_min=25, tm_sec=35, tm_wday=0, tm_yday=223, tm_isdst=0)
		想调用的话直接：a.tm_year = 2020就行了

os.path.exists(path)	判断路径或文件是否存在
os.path.isabs(path)		判断路径是否为绝对路径
isdir 
isfile
islink
samefile(path, path)	判断两个路径是否指向同一个文件

36. 将列表，字典等转化为二进制文件，就可以很好的做转变
	pickle模块

import pickle
my_list = [1, 2, 3, 3.45, [111, 455]]	#这里希望把这个列表保存成文件，永久保存
pickle_file = open('my_list.pkl', 'wb')		#这里一定要wb,写入+二进制
pickle.dump(my_list, pickle_file)			#这个是将文本输入进去
pickle_file.close()							#这个关闭一定要记得写！不然保存不了！
这样运行完就直接创建了my_list.pkl			#这里这个pkl文件不能用txt打开，因为打不开，是二进制

读取：load
pickle_file = open('my_list.pkl', 'rb')		#rb是读取二进制文件
my_list2 = pickle.load(pickle_file)			#load(file_name)，此时这个my_list2已经是原本的my_list了！就是数组！
print(my_list2)
#这样就可以读出来了


37.	异常处理：
	在出现异常的时候利用Py内部机制来直接处理掉
	
	AssertionError	断言语句（assert）失败	#使用assert方法判断的时候失败
	AttributeError	尝试访问未知的对象属性
	
	记住也可以用.get()来访问字典中不存在的key，因为什么都不会返回
	
38.	try语句，任何在try里面出现的异常都会被检测到，然后根据你的想法来进行操作
	
try:
	sum = 1 + '1'						#TypeError类型
	a = open('why am i a txt file')		#文件是不存在的
	print(a.read())
except OSError as reason:
	print('your file does not exist!' + str(reason))	#这样的话用户体验很好	#一定要把reason给str了！
except TypeError as reason:
	print('the sum you typed is not matching the type!' + str(reason))
finally:								#无论如何都会执行以下代码，无论错不错都应该执行的
	#一般finally在写入文件的操作中都会加入.close()


	1.这样的输出结果是：your file does not exist![Errno 2] No such file or directory: 'why am i a txt file'
	2.输出结果: the sum you typed is not matching the type!unsupported operand type(s) for +: 'int' and 'str'
	注意一下，如果是sum在前则只会返回第二个typeerror类型！
	
	try语句一旦检测到异常，则剩下的语句不会执行的！！！除非加入了finally，但加入了finally也是从错误到finally中间不会执行

也可以一起写:
	except (OSError, TypeError):
	
39.	else其他功能
	else和while
	while XX:
		if...
		break
	else:
		XX...
	
	这里else就是当while里面的每一个都不成执行的时候才会去执行
	
	for语句类似
	
	
	try也可以加入else！
try:
	int('abc')
except ValueError as reason:
	print('wrong!' + str(reason))
else:
	print('no problem!')
意思是当except不执行的时候就会执行下面的else!

40. with语句
	不用考虑文件关闭的问题
	
try:
	with open('test.txt', 'w') as f:		#这里with开头的话，就不需要考虑最后的创建文件之后的关闭问题了！
	for each_line in f:
		print(each_line)
except OSError as reason:
	print('error!' + str(reason))


41.	图形用户界面入门:GUI		#这里安装easygui的时候有小插曲！明明安装成功，但是却不能idle里面import！这是因为idle的版本和python的版本不一致!!!
	import easygui
	easygui.msgbox('i loe yuou ')
	
	也可以from easygui import *	#但是这样会覆盖同名的方法！
	那这样的话就可以直接写：msgbox('')了！！
	
	from easygui import as g
	
easygui的一个小项目:
import easygui as g
import sys

while 1:
	g.msgbox('welcome to the world of victor')
	msg = 'which girl do you want?'
	title = 'choose a girl'
	choices = ['grace', 'shirley', 'winnie']
	
	choice = g.choicebox(msg, title, choices)
	
	g.msgbox('your choice is ' + str(choice))
	
	msg = 'want to play it more?'
	title = 'please choose'
	
	if g.ccbox(msg, title):
	    pass			#user choose continue
	else:
        g.msgbox('huh, you dont want girl right?')
	    sys.exit(0)		#退出

注意：如果idle上运行不了easygui，那就换个编辑器就行了！

42. easygui整体介绍和用法：
	g.msgbox(msg="我一定要学会编程！", title="标题部分", ok_button="加油")
		这是三部分的messagebox的写法

	import sys
	import easygui as g
	if g.ccbox("亲爱的还玩吗?",choices=("还要玩！","算了吧")):		#注意这里ccbox只能添加两个选项！！其中第一个返回1，第二个返回0
		g.msgbox("还是不玩了，快睡觉吧！")
	else:
		 sys.exit(0)

	a = g.buttonbox(msg="你喜欢下面哪种水果?", title="", choices=("西瓜","苹果","草莓"))
		可以显示带有3个button的messagebox
		a返回的是你选择的choice
	
	类似的：
	a = indexbox(msg='Shall I continue?', title=' ', choices=('Yes', 'No'), image=None) 
		选择第一个yes的话返回0，否则1
	b = boolbox(msg='Shall I continue?', title=' ', choices=('Yes', 'No'), image=None) \
		选择第一个yes的话返回1，否则0

	a = g.multchoicebox(msg="请选择你爱吃哪些水果?",title="",choices=("西瓜","香蕉","苹果","梨"))
		下面相加多少选项都可以
	
	k = enterbox(msg='Enter something.', title=' ', default='', strip=True, image=None, root=None)
		默认返回的值会自动去除首尾的空格，如果需要保留首尾空格的话请设置参数 strip=False
	
	m = g.integerbox(msg="请输入您的得分",title="分数计",lowerbound=0,upperbound=100)
		为用户提供一个简单的输入框，用户只能输入范围内（lowerbound参数设置最小值，
		upperbound参数设置最大值）的整型数值，否则会要求用户重新输入。
	
	#多次输入
	msg = "请填写一下信息(其中带*号的项为必填项)"
	title = "账号中心"
	fieldNames = ["*用户名","*真实姓名","固定电话","*手机号码","QQ","*Email"]
	fieldValues = []
	fieldValues = g.multenterbox(msg, title, fieldNames)
	#print(fieldValues)
	while True:
		if fieldValues == None :
			break				#break仅Break掉这个if
			errmsg = ""
		for i in range(len(fieldNames)):
			option = fieldNames[i].strip()
			if fieldValues[i].strip() == "" and option[0] == "*":
				errmsg += ("【%s】为必填项   " %fieldNames[i])
		if errmsg == "":
			break
		fieldValues = g.multenterbox(errmsg,title,fieldNames,fieldValues)
	print("您填写的资料如下:%s" %str(fieldValues))

	
	passwordbox()
	passwordbox() 跟 enterbox() 样式一样，不同的是用户输入的内容用"*"显示出来，返回用户输入的字符串：
	msg = "请输入你的密码"
	user_password = g.passwordbox(msg)
	print(str(user_password))
	
	multpasswordbox()
	只有最后一个输入框显示为密码的形式（"*"）
	msg = "请输入用户名和密码"
	title = "用户登录接口"
	user_info = []
	user_info = g.multpasswordbox(msg,title,("用户名","密码"))
	print(user_info)
	
	diropenbox()
	msg = '选择一个文件，将会返回该文件的完整的目录'
	title = '文件选择对话框'
	default = ''		#这里可以是空的，如果不是空的，就默认从这里作为起点
	full_file_path = g.diropenbox(msg,title,default)
	print('选择的文件的完整的路径为：'+str(full_file_path))
	
43.	对象 = 属性 + 方法
	class类对象

class Turtle:
    color = 'green'
    height = 12
    def climb(self):
        print('I am climbing')
        return '123'
    def rape(self):
        print('I am being raped')

在调用的时候，直接tt = Turtle()	#这样一个对象就生成了
tt.color	#返回green
b = tt.climb()	#打印i am climbing
print(b)		#打印b的话就打印了123

面向对象：OO = object oriented
面向对象：封装 + 继承 + 多态

class Mylist(list):		#class后直接括号加类型那就是创建的类型
    pass
a = Mylist()
b = a + (b33)
print(b)	#Mylist里面直接创建了一个新的空的list

多态的话，就是不同的class里面都有同一个名字的方法，比如def fun(self)这样的，则可以同时存在！！A().fun()
	
class Ball:
	def setName(self, name):
		self.name = name
	def kick(self):
		print('I am %s, who kicked me!' % self.name)
a = Ball()
b = Ball()
a.setName('ballA')		#setName了之后系统就知道self.name是什么了
b.setName('ballB')

a.kick() = I am ballA, who kicked me!
b.kick() = I am ballB, who kicked me!
类在定义的时候，self在第一个是默认的要求，记住就行

44.	__init__(self)
	构造函数
	用上面那个例子：
class Ball:
	def __init__(self, name):	#这样的话就可以直接Ball完了之后直接传参数了
		self.name = name
	def kick(self):
		print('I am %s, who kicked me!' % self.name)
a = Ball('ballA').kick() 	# = I am ass, who kicked me!
b = Ball('ballB').kick()

共有和私有：
class中只需要将变量前面加上__就可以变成私有的了
class A:
	__name = 'asd'
	def getName(self):			#再强调一次，这个self必不可少！！
		return self.__name
外部不可以直接访问__name，只能内部进行访问，外部可以访问的是getName方法
a = A()
a.getName()

但是事实上，可以这样直接在外部访问到name：！！！！！！！！！！！！！！！！！！！！！！
a._A__name
所以python的私有是伪私有！


45.	继承
	子类可以继承父类的任何属性和方法：
class Parent:
	def hello(self):
		print('i am parent')
class Child(Parent):
	pass	#该处的 pass 便是占据一个位置，因为如果定义一个空函数程序会报错，
			#当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。

这里a = Child()
a.hello()也是可以的！！
如果字类的方法覆盖了父类的方法，则自动覆盖了！！

有一堆鱼的例子：
import random as r

class Fish:
	def __init__(self):
		self.x = r.randint(0, 10)
		self.y = r.randint(0, 10)
	def move(self):
		self.x -= 1
		print('我的位置是:', self.x, self.y)
class Goldfish(Fish):	#只需要继承生成的位置和移动就行了
	pass
class Selmon(Fish):
	pass
class Shark(Fish):
	def __init__(self):
		Fish.__init__(self)		#必须要加这句话！因为如果不加的话就自动覆盖了父类的init函数了！就没有xy了！
		self.hungry = True		#这里Fish.__init__(self)中的self不是父类的self，而是子类的！
	def eat(self):
		if self.hungry:
			print('eating now...')
			self.hungry = False
		else:
			print('i am full')
			
也可以使用super函数！更好！
class Shark(Fish):
	def __init__(self):
		super().__init__()		#这里直接写super就行，会自动的寻找父类的！！！会自动给寻找Shark()这个括号中的父类的！
		self.hungry = True
	def eat(self):
		if self.hungry:
			print('eating now...')
			self.hungry = False
		else:
			print('i am full')

也支持多重继承！
class C(Base1, Base2):
	pass
可以就多重继承了，但是这里可能出现bug，因为容易导致很混乱

46.	组合
池塘里面有x个乌龟有y个小鸟
class Turtle:
	def __init__(self, x):
		self.num = x
class Bird:
	def __init__(self, x):
		self.num = x
class Pool:
	def __init__(self, x, y):
		self.turtle = Turtle(x)
		self.bird = Bird(y)
		
	def print_num(self):
		print('池塘里一共有%d只乌龟，%d只鸟' %(self.turtle.num, self.bird.num))		#注意这里是self.turtle.num!!
组合就是把类放到一个新类里面，就不需要继承了。
组合用于横向的，一般没有什么大的相关性的类在一起的时候，就可以用组合。

47.	属性的名字与方法名相同的话，属性会覆盖掉方法：
class C:
	def x(self):
		print('123')

a = C()
a.x()这里会输出123
但如果你这样：
a.x = 122	#这里相当于直接定义了一个新的属性x，然后直接赋值为122，python不需要单独的声明变量！
这是x就与x()重名，就不能再用x()了！！

绑定：必须def的时候要有self
如果有：
class C:
	def printXY(self, x, y)

dd = C()
#此时dd.__dict__可以看到，这个dd就是个空的字典{}
dd.printXY(1, 5)，这里系统自动默认为: dd.printXY(dd, 1, 5)
所以只有当写了self的时候才能自动的把dd与1, 5绑定起来！

所以！当一个class中有def之后，这个class CC被del CC了之后，a = CC()这样实例化类就不可以了，但是原本已经实例化好的
那部分比如之前已经有b = CC()这样的，依然可以调用！也就是b.printXY(1, 5)依然可以用！除非关闭程序了内存释放了
但是如果def里面没有self，那就不能再del之后再这么调用了

48.	与类相关的BIF
issubclass(class, classinfo)

class A:
	pass
class B(A):
	pass
那么：
issubclass(B, A) = True，因为B是A的字类，但是这个是宽松的检查，因为issubclass(B, B) = True
这里classinfo可以是元组，里面是一串class
所有类的基类是：object
所以issubclass(B, object) = True


isinstance(object, classinfo)
检查实例对象是否属于classinfo这个类的
object如果不是实例对象，那么永远返回False，classinfo如果不是元组如果不是类，那么Typeerror
isinstance(a, c) 	#其中c = (A, B)
这样可以！而且A如果是B的子类，那么a, B，也可以是True!


hasattr(object, name)	#测试对象里面是否有指定的属性
class A:
    k = 10
a = A()
hasattr(a, 'k') = True！这里必须要用字符串形式，不然不认识！


getattr(object, name)	#返回某个类中的属性的值
getattr(a, 'k') = 10
getattr(a, 'q', 'do not exist!')	#返回'do not exist!'，这里第三个选项就是当没有这个q的时候就会返回这个东西！


setattr(object, name, value)		#给object赋值
setattr(a, 'q', '1233321')			#这样就创建了一个属性q，并赋值1233321
再尝试getattr：
getattr(a, 'q', 'not exist')


delattr(a, 'q')	#删除指定的属性，如果不存在就attributeerror

49.	
property()	其实听常用，但看个人习惯
class C:
	def __init__(self, size = 10):
		self.size = size
	def getSize(self):
		return self.size
	def delSize(self):
		del self.size
	def setSize(self, size):
		self.size = size
c = property(getSize, setSize, delSize)

那么这个时候，c1 = C()
c1.size 会返回10
c1.c 也会返回10
c1.c = 15 则会将size设置成15
del c1.size 就删除了
这里的property就是给了一个简便的写法而已，当代码属性的名字改变之后，就不用再全部大改了

50.	__init__里面绝对返回的是none，绝对不能返回任何东西！
	只有当给一个方法进行初始化的时候才需要用到__init__
	__del__垃圾回收
	比如：
class C:
	def __init__(self):
		print('__init__was referred to!')
	def __del__(self):
		print('__del__was referred to!')

c1 = C()
这个时候直接就会打印__init__was referred to!
然后c2 = c1, c3 = c2
然后del c2, del c1不会有反应
最后del c3的时候会返回__del__was referred to!，这是因为在del最有一个实例变量的时候会返回__del__的东西

51.	万物皆对象，做个小恶作剧：
class New_int(int):		#这里括号里一定是一种类型，比如int
	def __add__(self, other):				#这里的_add__就是+加号！
		return int.__sub__(self, other)		#这里一定不能写self + other，不然就会a + b和self + other无限递归
	def __sub__(self, other):
		return int.__add__(self, other)
这样：
a = New_int(5)
b = New_int(2)
a + b 就是-3
a - b就是7了
这就是自己写代码，不想调用别人的方法

比如重新定制print(a)的结果：
class A:
	def __str__(self):
		return 'i love you'
		
这样的话a = A()
print(a)就是那句话了

52.	定制一个计时器的类，start stop
使用time的localtime来获取当前时间

53.	numpy basics
import numpy as np
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
a * b = array([ 4, 10, 18])

bim = np.array([1, 2, 3, 4, 5, 6, 7, 8])
bim > 5 
	outcome: array([False, False, False, False, False,  True,  True,  True])
bim[bim > 5]
	outcome: array([6, 7, 8])
	#只有符合条件的会被选出来

array这里里面的东西都得是同一种类型的，如果是int则都是int，如果int中混入一个str，则所有自动都变成str

baseball = [[180, 78.4], [215, 102.7], [210, 98.5], [188, 75.2]]
a = np.array(baseball)
a[1:, 0:1]		#第一个参数是list中的list的大的范围，第二个是最小的list中的小范围
	outcome: array([[215.], [210.], [188.]])
a.shape
	outcome:	(4, 2)	#这个shape输出第一个是大的list数量，第二个是小list包含的个数
	
54. matplotlib foundamentals
plt.plot(x, y)
plt.scatter(x, y)
plt.xcale('log') 	#change the x-axis into a log version

datacamp one exercise:
# Scatter plot
plt.scatter(x = gdp_cap, y = life_exp, s = np.array(pop) * 2, c = col, alpha = 0.8)		#alpha is the transparency, c is the color

# Previous customizations
plt.xscale('log') 
plt.xlabel('GDP per Capita [in USD]')
plt.ylabel('Life Expectancy [in years]')
plt.title('World Development in 2007')
plt.xticks([1000,10000,100000], ['1k','10k','100k'])

# Additional customizations
plt.text(1550, 71, 'India')			#this is to set the place where the text is, the first 2 is the xy number on the graph!
plt.text(5700, 80, 'China')

# Add grid() call
plt.grid(True)		#网格线

# Show the plot
plt.show()

55.	python dictionnary
a = {1: 2, 3: 4, 6: 7}
print(a.keys())
print(a.values())	#to disparately print out the keys and values in a dict

each key in dict is unique! so when you a['qwe'] = 123 in a dict a, you add the qwe: 123 pair in the dict

del(europe['australia'])	 so that you deleted the australia pair

56. pandas
DataFrame
--------------
import pandas as pd

# Build cars DataFrame
names = ['United States', 'Australia', 'Japan', 'India', 'Russia', 'Morocco', 'Egypt']
dr =  [True, False, False, False, True, True, True]
cpc = [809, 731, 588, 18, 200, 70, 45]
cars_dict = { 'country':names, 'drives_right':dr, 'cars_per_cap':cpc }
cars = pd.DataFrame(cars_dict)
print(cars)

# Definition of row_labels
row_labels = ['US', 'AUS', 'JPN', 'IN', 'RU', 'MOR', 'EG']

# Specify row labels of cars
cars.index = row_labels			#the first column was not the number from 0 to x anymore, but row_labels

# Print cars again
print(cars)

----------------
# Import pandas as pd
import pandas as pd

# Fix import by including index_col
cars = pd.read_csv('cars.csv', index_col = 0)	#here index_col = 0 to make the first column not 0 to x anymore

# Print out cars
print(cars)

57.	pandas: loc() & iloc()

import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Print out country column as Pandas Series
print(cars['country'])

#this result is 
    US     United States
    AUS        Australia
    JPN            Japan
    IN             India
    RU            Russia
    MOR          Morocco
    EG             Egypt
    Name: country, dtype: object	#this sentence cannot be removed

# Print out country column as Pandas DataFrame
print(cars[['country']])			#use double square bracket!

#the result is:
				country
    US   United States
    AUS      Australia
    JPN          Japan
    IN           India
    RU          Russia
    MOR        Morocco
    EG           Egypt

# Print out DataFrame with country and drives_right columns
print(cars[['country', 'drives_right']])

outcome:
               country  drives_right
    US   United States          True
    AUS      Australia         False
    JPN          Japan         False
    IN           India         False
    RU          Russia          True
    MOR        Morocco          True
    EG           Egypt          True

the above dataframe can be sliced randomly with square brackets:
# Print out fourth, fifth and sixth observation
print(cars[3:6])
         cars_per_cap  country  drives_right
    IN             18    India         False
    RU            200   Russia          True
    MOR            70  Morocco          True
---------------------------
# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Print out observation for Japan
print(cars.iloc[2])				#use single square bracket to get a Series

# Print out observations for Australia and Egypt
print(cars.iloc[[1, 2], [1, 6]])		#use double square bracket to get a DataFrame

outcome:
         cars_per_cap    country  drives_right
    AUS           731  Australia         False
    EG             45      Egypt          True
	
-------------------
# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

#csv:
     cars_per_cap        country  drives_right
US            809  United States          True
AUS           731      Australia         False
JPN           588          Japan         False
IN             18          India         False
RU            200         Russia          True
MOR            70        Morocco          True
EG             45          Egypt          True

# Print out drives_right value of Morocco
print(cars.loc[['MOR'], ['drives_right']])		#when you use loc and iloc, be careful of the sequence of the 2 arguments!

# Print sub-DataFrame
print(cars.iloc[[4, 5], [1, 2]])

outcome:
     country  drives_right
RU    Russia          True
MOR  Morocco          True


58.	python can compare two strings:
'carl' < 'chris'
outcome: True

59. numpy logical_or/ and/ not

import numpy as np
my_house = np.array([18.0, 20.0, 10.75, 9.50])
your_house = np.array([14.0, 24.0, 14.25, 9.0])

# my_house greater than 18.5 or smaller than 10
print(np.logical_or(my_house > 18.5, my_house < 10))		#in this way, numpy can directly select which ones is u want.

# Both my_house and your_house smaller than 11
print(np.logical_and(my_house < 11, your_house < 11))

--------------------
cars:
     cars_per_cap        country  drives_right
US            809  United States          True
AUS           731      Australia         False
JPN           588          Japan         False
IN             18          India         False
RU            200         Russia          True
MOR            70        Morocco          True
EG             45          Egypt          True


# Extract drives_right column as Series: dr
dr = cars['drives_right']

# Use dr to subset cars: sel
sel = cars[dr]

outcome:
         cars_per_cap        country  drives_right
    US            809  United States          True
    RU            200         Russia          True
    MOR            70        Morocco          True
    EG             45          Egypt          True


print(cars[np.logical_and(cars['cars_per_cap'] < 500, cars['cars_per_cap'] > 100)])
# in this way the 2 dimensional filtering was completed

59.	
areas = [11.25, 18.0, 20.0, 10.75, 9.50]

for index, area in enumerate(areas) :			#here you need to print the index and the content, so must use the enumerate()!
    print("room " + str(index) + ": " + str(area))

europe = {'spain':'madrid', 'france':'paris', 'germany':'berlin', 'austria':'vienna' }
for a, b in europe.items():						#this is items(), there is an 's' here
    print('the capital of ' + a + ' is ' + b)

----------------------------------------
array([[ 74, 180], [ 74, 215], [ 72, 210])
										#if u want to print out every number, use nditer()
for x in np.nditer(np_baseball):				#np.nditer(np_baseball)
    print(x)

----------------------------------------
cars.csv:
     cars_per_cap        country  drives_right
US            809  United States          True
AUS           731      Australia         False
JPN           588          Japan         False
IN             18          India         False
RU            200         Russia          True
MOR            70        Morocco          True
EG             45          Egypt          True

for a, b in cars.iterrows():
    print(a)
    print(b)

	#outcome:	#shown in this way for all contents
    US
    cars_per_cap              809
    country         United States
    drives_right             True
    Name: US, dtype: object
	
for lab, row in cars.iterrows() :
    print(lab + ': ' + str(row['cars_per_cap']))		#because lab represents the first column, and row is the rest serie

	#outcome:
	US: 809
    AUS: 731
    JPN: 588

	#add an column named COUNTRY: use directly the loc[] function
for x, y in cars.iterrows():
    cars.loc[x, 'COUNTRY'] = y['country'].upper()		#very important, 'loc' can add an column! but not very efficient
	
	#outcome:
     cars_per_cap        country  drives_right        COUNTRY
US            809  United States          True  UNITED STATES
AUS           731      Australia         False      AUSTRALIA
JPN           588          Japan         False          JAPAN
IN             18          India         False          INDIA
RU            200         Russia          True         RUSSIA
MOR            70        Morocco          True        MOROCCO
EG             45          Egypt          True          EGYPT	
	
cars['COUNTRY'] = cars['country'].apply(str.upper)		#very important, and efficient, also add an column 'COUNTRY', same result
	(# also you can type like cars['country'].apply(len)) etc
	
	
seed()，随机数种子对后面的结果一直有影响。同时，加了随机数种子以后，后面的随机数组都是按一定的顺序生成的。	
	# if you set up a seed 1, then everytime when you type seed(1), you will get a same string of random numbers, 
	# so that your experiments are reproducible
	
rand() generates num of 0 - 1
randint(1, 6) generates 1 - 5
	# you can use np.random.randint(1, 5) in numpy package!

# if u want to itinerate 10 times, use 'for a in range(10)'


60.	
plt.cla() # 清除axes，即当前 figure 中的活动的axes，但其他axes保持不变。
plt.clf() # 清除当前 figure 的所有axes，但是不关闭这个 window，所以能继续复用于其他的 plot。
plt.close() # 关闭 window，如果没有指定，则指当前 window。
	
# this is important in visulization

import numpy as np
import matplotlib.pyplot as plt

# Simulate random walk 250 times
all_walks = []
for i in range(250) :
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)
        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)

        # Implement clumsiness				# this is very useful! if there is a 0.1% chance of accident, use rand() to include this situation
        if np.random.rand() <= 0.001 :
            step = 0

        random_walk.append(step)
    all_walks.append(random_walk)

# Create and plot np_aw_t
np_aw_t = np.transpose(np.array(all_walks))	# here transpose is to make the matrix more visulisable 
plt.plot(np_aw_t)
plt.show()

ends = np_aw_t[-1, :]						#in np.array, you can use things like [1, 2: 4] to slice

# Plot histogram of ends, display plot
plt.hist(ends)
plt.show()	


61.	self-defined functions. u can use the Docstring to make others understand the function using """x, t"""
	(triple double quotes)

62.	#you can use tuple in a function to return more than 1 values

def quo(x, y):
	a = x ** y
	b = y ** x
	c = (a, b)
	return c		# in this case 2 values were returned, c[0] refers to the first returned number
	

	# for a tuple num = (1, 2, 3), you can use:
	num1, num2, num3 = num
	# then num1 = 1, num2 = 2, num3 = 3

def shout_all(word1, word2):
    shout1 = word1 + '!!!'
    shout2 = word2 + '!!!'
    shout_words = (shout1, shout2)					# here a tuple was created
    return shout_words
yell1, yell2 = shout_all('congratulations', 'you')	# here the outcome was set in 2 variables
print(yell1)
print(yell2)


63. 
def count_entries(df, col_name):
    langs_count = {}
    col = df[col_name]
    for entry in col:
        if entry in langs_count.keys():
            langs_count[entry] += 1
        else:
            langs_count[entry] = 1
    return langs_count
result = count_entries(tweets_df, 'lang')
print(result)


64. for a local variable, one can use global to make it a global one, but remember once globalized, it is a global variable

for difference in global and nonlocal
第一，两者的功能不同。global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，
而nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal
位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）

第二，两者使用的范围不同。global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，
global修饰后也可以直接使用，而nonlocal关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生
错误

nonlocal只能用在嵌套里面，出了母function就不能再调用了

# 嵌套函数：nested function

def three_shouts(word1, word2, word3):
    """Returns a tuple of strings
    concatenated with '!!!'."""

    def inner(word):
        return word + '!!!'
    return (inner(word1), inner(word2), inner(word3))
print(three_shouts('a', 'b', 'c'))


def echo(n):
    """Return the inner_echo function."""
    def inner_echo(word1):
        echo_word = word1 * n
        return echo_word
    return inner_echo           #这里什么都不写的话，在调用的时候一定要echo(2)('qwe')这样！
twice = echo(2)
thrice = echo(3)
print(twice('hello'), thrice('hello'))


65. # you can input as many parameters as you like in a function using 'def x(*args)'
    
def gibberish(*args):       # important *args

    hodgepodge = ''
    
    for word in args:
        hodgepodge += word
        
    return hodgepodge
    
one_word = gibberish('luke')
many_words = gibberish("luke", "leia", "han", "obi", "darth")
print(one_word)
print(many_words)

    # you can also input a dictionnary in to a function by using 'def x(**kwargs)'


def report_status(**kwargs):

    print("\nBEGIN: REPORT\n")
    
    for keys, values in kwargs.items():
        print(keys + ": " + values)
        
    print("\nEND REPORT")

report_status(name="luke", affiliation="jedi", status="missing")


def foo(x,y=1,**kwargs):
    print(x)
    print(y)
    print(kwargs)
foo(1,a=2,b=3,c=4)#将1按照位置传值给x，y按照默认参数为1，a=2, b=3, c=4以字典的方式给了kwargs


# 还有一个问题，kwargs关键字的key必须和函数定义时,形式参数的名称一模一样
def some_kwargs(kwarg_1, kwarg_2, kwarg_3):
    print("kwarg_1:", kwarg_1)
    print("kwarg_2:", kwarg_2)
    print("kwarg_3:", kwarg_3)

kwargs = {"kwarg_1": "Val", "kwarg_2": "Harper", "kwarg_3": "Remy"}
some_kwargs(**kwargs)
# kwarg_1: Val
# kwarg_2: Harper
# kwarg_3: Remy

# 字典key和函数定义时的形式参数名称不一致
kwargs1 = {"kwarg_1": "Val", "kwarg_2": "Harper", "kwarg_4": "Remy"}
some_kwargs(**kwargs1)
# TypeError: some_args() got an unexpected keyword argument 'kwarg_4'

# 字典的参数内容少了

kwargs1 = {"kwarg_1": "Val", "kwarg_2": "Harper"}
some_kwargs(**kwargs2)
#TypeError: some_args() missing 1 required positional argument: 'kwarg_3'


66. lambda function: easy to use functions: no need to name a function

echo_word = (lambda word1, echo : word1 * echo)      # easy to write
result = echo_word('hey', 5)

-----------
# map() 会根据提供的函数对指定序列做映射。
nums = [2, 4, 6, 8, 10]
result = map(lambda a: a ** 2, nums)        #the third parameter is input and return parameter! nums即为参数！

print(list(result)) = [4, 16, 36, 64, 100]

map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])
outcome: [3, 7, 11, 15, 19]
-----------

#filter(function, iterable)
# filter() to filter out the wanted outcome

fellowship = ['frodo', 'samwise', 'merry', 'pippin', 'aragorn', 'boromir', 'legolas', 'gimli', 'gandalf']

result = filter(lambda a: len(a) > 6 , fellowship)
result_list = list(result)

outcome:
['samwise', 'aragorn', 'boromir', 'legolas', 'gandalf']


过滤出1~100中平方根是整数的数：
import math
def is_sqr(x):
    return math.sqrt(x) % 1 == 0
 
tmplist = filter(is_sqr, range(1, 101))
newlist = list(tmplist)
print(newlist)

outcome:[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]


67. reduce()
reduce() 函数会对参数序列中元素进行累积
def add(x, y) :            # 两数相加
    return x + y
a = reduce(add, [1,2,3,4,5])   # 计算列表和：1+2+3+4+5

outcome: a = 15

reduce(lambda x, y: x+y, [1,2,3,4,5])  # 使用 lambda 匿名函数
outcome: 15


68. error handling using try-except

try:
except:

也可以用raise方法：

def shout_echo(word1, echo=1):
    if echo < 0:
        raise ValueError('echo must be greater than or equal to 0')     # use raise to clearify the error

    echo_word = word1 * echo
    
    shout_word = echo_word + '!!!'

    return shout_word

shout_echo("particle", echo=-5)

此时下面的valueerror里面就会写raise里面的内容


69. #使用Lambda将序列中开头是'RT'的筛选出来

result = filter(lambda a: a [0: 2] == 'RT', tweets_df['text'])
res_list = list(result)
for tweet in res_list:
    print(tweet)
   

70. about DataFrame
    
    a is a dataframe
    a.columns   直接返回的是list形式的columns的抬头名字
    a['qwe']    qwe为columns的其中一个名字，则返回的是这一个名字下面的所有值，也是以dataframe形式返回的
  

homelessness is a DataFrame
# Print the head of the homelessness data
print(homelessness.head())      #返回前几行的信息

# Print information about homelessness
print(homelessness.info())      #基本信息，比如有多少个项，内存占用多少等

# Print the shape of homelessness
print(homelessness.shape)       #多少行多少列

# Print a description of homelessness
print(homelessness.describe())  #均值最大最小值等
    
# Print the values of homelessness
print(homelessness.values)      #DataFrame里面每一行的信息汇总

# Print the column index of homelessness
print(homelessness.columns)     #每一列的抬头汇总

# Print the row index of homelessness
print(homelessness.index)       #每一行的抬头汇总


Pandas关于DataFrame的sorting很强大
1. 
homelessness_fam = homelessness.sort_values("family_members", ascending=False)
    #sort_values(['asd'])是直接排序，ascending是从小到大还是从大到小

# Print the top few rows
print(homelessness_fam.head())

2.  
# Sort homelessness by region, then descending family members
homelessness_reg_fam = homelessness.sort_values(['region', 'family_members'], ascending = [False, True])
    #可以多个一起筛选，然后每一个都可以按要求来进行ascending or not
# Print the top few rows
print(homelessness_reg_fam)


#打印多个列：
state_fam = homelessness[['state', 'family_members']]   
# Print the head of the result
print(state_fam.head())

#多个列选项同时满足
# Filter for rows where family_members is less than 1000 and region is Pacific
fam_lt_1k_pac = homelessness[(homelessness['region'] == 'Pacific') & (homelessness['family_members'] < 1000)]

#同时满足的条件中间一定用()括起来！


# Subset for rows in South Atlantic or Mid-Atlantic regions
south_mid_atlantic = homelessness[(homelessness["region"] == "South Atlantic") | (homelessness["region"] == "Mid-Atlantic")]
#可以用|来满足or条件


canu = ["California", "Arizona", "Nevada", "Utah"]
# Filter for rows in the Mojave Desert states
mojave_homelessness = homelessness[homelessness['state'].isin(canu)]
#这个作用是将dataframe里面region列中在canu list里面出现过的这些地名的所有信息都筛选出来



























