1.	python的学习
	print("i love you\n" * 8)
	python没有;,这种标点符号！

2.	设计一个小游戏
#coding: gbk
print('-------------我爱鱼c工作室--------------')
temp = input("猜一下小甲鱼现在心里想的是哪个数字:\n")		
guess = int(temp)											//这里将temp强行转化成Int格式
if guess == 8:
    print("卧槽，你是小甲鱼心里蛆虫吗？！")
    print("哼，猜中了也没有奖励！")
else:
    print("猜错啦，小甲鱼现在心里想的是8！")
print("游戏结束，不玩啦~")

3.	BIF = built-in function，内置程序

4.	大小写的变量不一样！

5.	原始字符串：
	str = 'C:\desktop\nuser'	这里打印的话会有转义现象，需要这样：
	str = r'C:\desktop\nuser'	加一个r即可
	#直接敲str的结果是'C:\\desktop\\nuser'
	
	注意：原始字符串在最后是不能加反斜杠的
	
	如果想打印直接换行，可以直接这样：（更快）
	str = """
	我爱你我爱你我爱你
	我爱你我爱你
	我爱你
	我
	"""
	然后输入str就会自动返回'\n我爱你我爱你我爱你\n我爱你我爱你\n我爱你\n我\n'
	这样刚刚好
	
6.	and逻辑操作符，可以连接任意的表达式并且返回一个布尔类型的值。
	or逻辑符，同理
	not逻辑符：取相反布尔类型的值
	
7.	random模块中有一个randint()函数。
	返回一个随机的整数。
	
8.	可以直接这样写数据: a = 1.5e11，就是1.5 * 10 ^ 11
	
	布尔类型是整数！
	你可以这么写：true + true
	true = 1, false = 0
	
	强制转型：int(), float(), str()
	
	int(5.99) = 5
	
	获得关于类型的信息: type(), isinstance()
	
	isinstance()用法：（返回布尔类型）
	a = '我爱你'
	isinstance(a, str)
	这句就会打印true。
	这里各种类型是：int float bool str
	
9.	算数操作符
	a +=
	b *=
	c */
	这样可以，但是a++这样不行
	
	a = b = c = d = 10
	直接方便赋值
	
	%：取余数
	//：取整数
	**：幂
	
	10 // 3.0只要里面有float，则结果是float结果。
	
	8 * -3可以直接写，可以不用加括号在负数这里
	
	幂运算中，幂比它左侧的优先级高，右侧的优先级低
	-3 ** 2，这里输出-9
	
	not逻辑符，取相反的布尔类型的值。
	0认为是false,其他认为是true
	所以not 0 = true
	not 4 = false
	
	3 < 4 < 5
	这样写也是合法的，会自动改写成3 < 4 and 4 < 5
	
	x, y = 4, 5
	
10.	分支语句：
	if, if, if
	if: else:
	if: elif:
	
	三元操作：
	可以这么来写：
	guess = x if x > y else y
	(即当x>y的时候Guess赋值x反之赋值y)
	
11.	assert用法
	比如在你的程序中有x和y了，然后你需要之后使用到x和y，但是你想法是x一定大于y的，那么这个时候就可以加：
	assert x > y
	如果之后报错就会指明是这一点出错了！

12.	while for 循环

	for 目标 in 表达式：
		循环体
	
	比如打印victor但是里面每个字母之间加上一个空格，可以这样：
	f = 'victor'
	for i in f:
		print(i, end = ' ')
		
	number = ['vic', 'grace', 'leeloo']		#创建一个列表
	for each in number:
		print(each, len(each))				#打印了每一个列表中的字符串，加上它的len长度
	
	range()函数
	list(range(5))							#[0, 1, 2, 3, 4]输出结果，从0开始一直到n-1!
	
	for i in range(6):
		print(i)							#这样输出结果是竖着的，如果想要横着，则print(i, end = '')
	
	for i in range(1, 6, 2):				#每个数之间相隔2（这里注意一旦写了第三个数，则意味着这三个参数必须写满）
		print(i)
		
	break：终止当前循环并跳出
	用于while True:的循环中，不然永远也false不了
	
	continue语句：跳出本次循环，进行下一次循环（从头执行循环）

13.	列表
	数组
	
	创建普通列表：number = ['vic', 'grace', 'leeloo']
	输出grace: number[2]
	
	创建混合类型
	mix = [1, '123', [1, 2, 3, 4]]		#里面什么都可以加
	len(mix) = 3
	
	向列表添加元素
	append()
	number.append(123)					#添加到最后
	
	append()每次只能添加一个元素
	extend()添加一个列表（原理是用一个列表去扩展另一个列表，所以添加的也必须是列表）
	
	mix.extend(['阿阿阿', '哦哦哦'])
	但是append([1, 2])这样的话是添加一个元素，这个元素是个列表而已
	len()如果()中是一个单词，则返回单词的字母数量，如果是list，则返回元素数量
	
	insert()可以插入，插第一个位置，则insert(0, '123')

14.	从列表删除元素：
	remove()，括号是参数对象的
    mix = [1, '123', [1, 2, 3, 4]]
    则remove的时候需要mix.remove('123')，括号中是list中的元素
    好处是，你不需要知道remove的元素是第几个，只需要知道在里面即可
    
    del，这不是一个方法而是语句
    del mix[1]
    则第二个元素被remove掉了
    del mix整个全删掉
    
    pop()
    mix.pop()这个是将mix中的最后一个元素删除，并赋值给pop()
    a = mix.pop()
    此时a是原来mix中最后一个元素，且mix中已经删除了最后一个了
    
    也可以加入参数
    mix.pop(1)
    则自动返回第二个元素并且删除第二个元素
    
    列表切片：slice()，一次性获取多个元素
    mix[1: 3]
    原列表没有任何更改
    mix[ :3] = mix[0: 3]
    如果要复制一份列表，则a = mix[:]   中间这个:绝对不能省！
    
    
    list1 = [123]
    list2 = [234]
    这里list1 < list2，因为第一个数要小
    list1 + list2，这样类似extend的连接操作
    但是这个加号两边的对象必须是同一个类型的！
    
    list1 * 3，就是复制了3次
    
    123 in list1，这句话会返回True，因为123在list1中
    234 not in list1, True
    
    list3 = [1, 2, [1, 2, 3, 4, 5]]
    如果要找5这个数，则可以list3[2][4]连用两个中括号！
    
    list3.count(123)    表示返回123在list3中的次数
    list3.index(123)    表示返回123在list中第一次出现的位置
    list3.index(123, 4, 7)  表示返回123在list3中第4-7位置中出现的位置（因为可能重复很多次）
    
    reverse将整个列表反转
    list3.reverse()
    
    sort()用指定的方法对list排序，默认是从小到大
    list3.sort()    从小到大
    从大到小：list3.sort().reverse()
    或者list3.sort(reverse = True)
    
    重要！
    以后在复制list的时候，一定要用a = list3[:]的方式！因为如果直接a = list3的话，list3改变了a也跟着改变！
    a = list3这样只是相当于增加了一个标签而已，不要这样做
    
    list3[1: 3]这是获取了两个值！从第2个开始往后选2个！！！！！！！！！！
    list3[2:]这样从第3个到最后一个（不包括第二个）！！！！！！！！！！！
    list3[: 2]这样是从0到第2个！！！！！！！！！！！！！！！！！！！！！！
    
15. 元组：不可改变的
    列表：可以任意改变里面的元素
    tuple = (1, 2, 3, 4, 5, 6, 7, 8)
    这就是元组
    tuple[2] = 3
    
    元组拷贝一样tuple[:]
    
    temp = (1)
    这样创建的还是一个int
    temp = 1, 2, 3, 4
    这样type(temp)创建了一个tuple元组了
    如果只要创建一个1个数字的元组，则需要：
    temp = (1,)     或者temp = 1,
    这个逗号不能少！
    
    8 * (8,) = (8, 8, 8, 8, 8, 8, 8, 8) 是重复的意思
    
    
    更改元组：
    比如添加一个元素
    temp = ('victor', 'grace', 'leeloo')
    在第二个中间插入lee，这样：
    temp = temp[: 1] + ('lee',) + temp[1:]     这里的lee后面必须有,！！
    
    del temp直接全部删了，不推荐，因为python会自动回收，与java一样
   
16.	字符串的方法
	字符串改为大写：
	
	str = 'lizhen ning'
	str.capitalize()
	只是将这个字符串的第一个字符改为大写
	
	str.casefold()
	全部改成小写，返回新的字符串，之前的字符串没有改变
	与lower()的区别：
	lower函数只支持ascill表中的字符，而casefold则支持很多不同种类的语言。
	
	str.center(40)
	返回左边右边都有40个空格，然后居中了
	
	str.count(zh)
	查找zh在str中出现的次数
	
	str.endswith('ng')
	检查str是否以ng结束，是就返回True
	注意！还可以加上范围！
	str1 = 'lizhen ning'
	str1.endswith('h',0,4)
	返回True，也就是说是0-4个字符的位置中最后一个字符（这里似乎不用n-1了）
	单独一个参数的话：
	str1.endswith('h',4)则是第4个之后到末尾的最后一个字符
	
	str.startswith()
	同理
	
	str.find('zh')
	str.find('', 1, 8)（可加范围参数）
	如果能找到就返回下标（从0开始），如果找不到就返回-1
	
	str.index('zh', 1, 9)（可加范围参数）
	结果跟find一样，但是如果找不到会报错，而不是返回-1
	
	str.isalnum()		至少一个字符并且所有都是数字或者英文字母，返回True
	str.isalpha()		字符串中至少有一个字符并且全都是英文字母返回True
	str.isnumeric()		字符串中只包含数字字符，返回True
	
	str.isdecimal()		里面全都是十进制数字返回True
	
		区分：
		isdigit()
		True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字
		False: 汉字数字
		Error: 无

		isdecimal()
		True: Unicode数字，，全角数字（双字节）
		False: 罗马数字，汉字数字
		Error: byte数字（单字节）

		isnumeric()
		True: Unicode数字，全角数字（双字节），罗马数字，汉字数字
		False: 无
		Error: byte数字（单字节）
		
		结论：以后最好只用isnumeric就行了。。
		
	str.islower()
	如果str中包含英文并且全都是小写则返回True
	
	str.isspace()
	如果只包含空格，则返回True
	
	str.istitle()
	str中如果每个单词首字母都大写其他都小写则返回True
	
	str.isupper()
	所有的字符都是大写的返回True
	
	str = 'l love you'
	str.join('abc') 返回 'al love youbl love youc' #a b c插入进去
	
	str.lower()
	所有大写字母转为小写
	
	str.upper()
	转为大写
	
	str.lstrip()
	去掉字符串所有左边的空格
	
	str.rstrip()
	去掉字符串所有末尾的空格
	
	str.partition(sub)
	这个挺有用的，可以直接分离字符串变成包含3元素的元组
	str = 'please dont do that'
	str.partition('dont')
	结果是：
	('please ', 'dont', ' do that')
	（有重复出现的只区分第一个）
	
	str.replace('old', 'new', [count])
	str = 'abcccdeff'
	str.replace('c', 'x') = 'abxxxdeff'
	str.replace('c', 'x', 2) = 'abxxcdeff'	#只将前两个c改了
	
	str.rfind(sub)
	类似find()，但是从右边开始找，可以加范围参数
	
	str.rindex()
	类似index()，但是从右边开始找，可以加范围参数
	
	str.rpartition()
	类似partition()
	
	str.split()
	不带参数默认分割空格
	类似partition，但用的更广！
	str = 'abcccddefcc111c1'
	str.split('c') = ['ab', '', '', 'ddef', '', '111', '1']
	自动生成数列，并且将c抹去，如果连着两个c则生成''
	str.split('c', 2) = ['ab', '', 'cddefcc111c1']
	只把前两个c给分割开了
	
	str.strip()
	把前后的空格都删掉
	str = 's11ssio ooiuss9s'
	str.strip('s') = '11ssio ooiuss9'
	则仅把前后的s给去掉，加了s开头如果还是空格就不再删除了
	
	str.swapcase()
	把大小写反过来
	
	str.title()
	str中所有单词的开头变成大写
	
	str.translate()
	str = 'ssbbaabbfutzss3e'
	str.translate(str.maketrans('s', 'b')) = 'bbbbaabbfutzbb3e'
	这里把所有s换成了b，是其中一种用法
	单独返回str.maketrans('s', 'b') = {115: 98}
	ASCII编码
	
	zfill(width)
	str = 'ssbbaabbfutzss3e'
	len(str) = 16
	str.zfill(20) = '0000ssbbaabbfutzss3e'
	前面填充4个0
	#这个可以用来整理参差不齐的数据，转化为0之后再切片或者转成空格即可
	
17.	字符串的格式化：按照统一的规格去输出字符串
	（比如不同进制）
	
	format函数
	1.位置函数
		a = "{0} love {1} {2}"
		a.format("I", "grace", "very much") = 'I love grace very much'
		
	2.关键字参数
		x = "{a} love {b} {c}"
		x.format(a = "I", b = "grace", c = "very much") = 'I love grace very much'
	也可以混合着用，x = "{0} love {b} {c}"，但是数字必须在前面
	
	四舍五入定点数
	'{0:.1f}{1}'.format(27.789, "GB") = '27.8GB'
	冒号后的.1表示四舍五入到小数点后1位，2就是两位
	
18.	字符串操作符
	%c:格式化字符及其ASCII码
	'%c' %97 = 'a'
	'%c%c%c' %(97, 98, 99) = 'abc'
	'%c %c%c' %(97, 98, 99) = 'a bc'
	其实就是97 98 99按照'%c'排列的方法合并到''里面去
	多个数必须加括号
	
	'%s' %'i love you' = 'i love you'
	'abc%s' %'i love you' = 'abci love you'
	本质上就是替换的过程
	
	%d表示数字
	'%d + %d = %d' %(4, 5, 6) = '4 + 5 = 6'
	只是做了个替换而已
	
	'%f' %27.878 = '27.878000'
	默认会精确到六位数
	
	'%e' %27.878 = '2.787800e+01'
	
	m.n这个很重要！
	'%5.1f' %27.46 = ' 27.5'
	5表示整个字符串最小宽度是5，.1表示四舍五入到小数点后1位
	'%6.2f' %27.4665 = ' 27.47'
	
	加上-表示左对齐
	'%-10d' %27.787 = '27        '
	'%10d' %27.787 = '        27'
	
	需要数字前面显示正负号的话，+即可
	'%+4d' %28.3 = ' +28'
	
	前面加上0的话就意味着前面的空格用0填充
	'%010d' %23.4 = '0000000023'
	
19.	转义字符
	单引号\'
	同理：\"
	\n换行
	\t = tab
	\v纵向制表符
	\r = enter
	\f 换页符
	\0 表示空字符
	
20.	列表，元组，字符串
	list()生成列表
	a = list()
	那么a = []
	
	b = 'i love you'
	b = list(b)
	b = ['i', ' ', 'l', 'o', 'v', 'e', ' ', 'y', 'o', 'u']
	把字符串列表了
	
	元组也可以通过list转化为list
	c = (1, 2, 3, 4, 5)
	c = list(c)
	c = [1, 2, 3, 4, 5]
	
	d = [1, 2, 3, 4, 5]
	d = tuple(d)		#转化为元组
	d = (1, 2, 3, 4, 5)
	
	str转化为字符串
	len(d) = 5	#5个元素
	
	max()
	返回一组数最大值，或者一个字符数组的最大ASCII码的字母，比如max(b) = v
	这里注意，单独的一个字符串也可以max min!
	比如
	a = '182848301'
	max(a) = 8
	
	min()
	同理
	
	使用max min的话数据类型必须统一！不能既有数字又有字符串的
	
	sum()
	a = [12, 23, 45, 67]
	sum(a, 8) = a里面的和加上8
	
	sorted()
	默认从小到大排
	list(reversed(a))
	
	a = [12, 23, 45, 67]
	list(enumerate(a)) = [(0, 12), (1, 23), (2, 45), (3, 67)]
	自动编号
	
	a = [12, 23, 45, 67, 999, 1298]
	b = [1, 2, 3, 4, 5, 7]
	list(zip(a, b))
	#如果直接输出zip(a, b)会得到<zip object at 0x0000019DF9CAEE88>，需要用list的方法来转变
	list(zip(a, b)) = [(12, 1), (23, 2), (45, 3), (67, 4), (999, 5), (1298, 7)]
	#会逐一配对，多余的数字不再管
	
21.	函数
	切割方法
	定义函数一定要有小括号
def Myfirstfunction():
	print('this is my first function')
	
def Mysecondfunction(name):
	print(name + 'i love you')
	
	函数的返回值return
def Mythirdfunction(a, b):
	return a + b
	用了return的话是可以直接赋值的，比如axe = Mythirdfunction(1, 4)
	
	形参:parameter
	实参:argument
	
def Mythirdfunction(a, b):
	'i love aaaa'	#这个是文档
	return a + b	
	这里定义了一个字符串语句，想调用文档的话Mythirdfunction.__doc__ 会输出 'i love aaaa'
	写这个是为了让别人更好的理解
	
	如果有时候ab在输入的时候忘记顺序了，可以这样：
	Mythirdfunction(b = 456, a = 123)

	默认值参数
def Mythirdfunction(a = 1, b = 4):
	return a + b
	调用的时候可以直接Mythirdfunction
	也可以Mythirdfunction(4)
	这里4就赋值给a了，按顺序来的
	
	收集参数：
	写函数的作者有时候也不知道会有多少个参数的时候可以在参数前面加上*
def test(*params):
	print('参数长度是', len(params))	#这里一定是,隔开！！
	print('第二个参数是', params[1])
	
调用：test('小甲鱼', 123, '888')
	结果：
	参数长度是 3
	第二个参数是 123
	
如果想收集函数和关键词函数同时用，比如def test(*params, key):
	那你在写test()的时候必须是写明key = XXX
	
Python所有函数都有返回值的，就算没有return，也会返回none
def back():
	return [1, 'i lov eyou', 3.14]
	
是可以返回一个数组的
也可以直接return 1, 'i lov eyou', 3.14
这样返回的就是元组了


有一个小点，需要注意：
函数外面赋值的字符，尽量不要跟函数内部的参数名一致，如果一样的话，并不会报错，而是很容易
搞不清楚谁调用了谁，很容易逻辑出错。局部变量和全局变量可以重名，因为在不同的栈当中，但是调用要很小心

可以在函数内部访问全局变量，但是不要试图去修改它！

如果需要在局部地区更改全局变量，则需要加上global关键字
a = 10
def myfun():
	global a		#global关键字
	a = 15
	print(a)
这个时候再myfun()就打印的是a = 15了

22.	闭包的概念：
def funx(x):
	def funy(y):
		return x * y
	return funy			#funy本质是函数，所以funx输出的是函数

调用的话：比如：
i = funx(8)
type(i) = function
i(5) = 40
也可以这么调用：
funx(5)(8) = 40

nonlocal的用法：强制转化成非局部变量
def funx():
	x = 5
	def funy():
		x *= x
		return x
	return funy()		#这里局部变量是不可以改变全局变量的，local variable 'x' referenced before assignment
	
	如果想引用x*=x，则用nonlocal用法
def funx():
	x = 5
	def funy():
	    nonlocal x
		x *= x
		return x
	return funy()	
输出funx() = 25

还有一点，上面的程序funx()中的return funy()和return funy其实都可以，因为return funy的话是返回一个function
而return funy()是将funy()函数中的return x给直接return出来了

23.	lamba函数
	匿名函数
	平面几何的直线方程
	
	g = lambda x: x * 5 + 1
	g(5)就可以直接调用了
	k = lambda x, y: x + y
	k(4, 6)

使用Lambda函数就不用费劲命名了

24.	filter()
	过滤器，可以保留想要的东西
	默认的话，就把任何非true的内容给过滤掉
	比如：
	a = [1, 0, True, False, 1 < 2]
	list(filter(None, a)) = [1, True, True]		#一定要用List来引用！
	
	filter中第一个参数可以设置为过滤的要求
	比如：
	筛选出奇数的过滤器：
def odd(a):
	return a % 2	#这里odd返回为0的是偶数，返回为1的是奇数，1是true，所以可以自动filter选择（也可以加not选偶数）
temp = range(10)	#默认即是list类型，不用再list(temp)
b = filter(odd, temp)
list(b)		#返回结果是：[1, 3, 5, 7, 9]

25.	filter + lambda方便实现删选奇数
	list(filter(lambda x: x % 2, range(10))) = [1, 3, 5, 7, 9]
	偶数的话：
	list(filter(lambda x: not x % 2, range(10))) = [0, 2, 4, 6, 8]
	(因为 not 1 = False, not 0 = True)
	
26. map()
	映射：
	list(map(lambda x: x * 2, range(10))) = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
	每个range(10)中的数据都乘以2输出为list
	
27. 递归：函数调用自己
	python系统默认递归层数是100层，可以手动修改：
	import sys
	sys.setrecursionlimit(1000)
	
	用递归写阶乘：
def quant(x):
	if(x == 1):
		return 1
	else:
		return x * quant(x - 1)
调用的话直接quant(6) = 720
	
	非递归版本：
def quant(x):
	result = x
	for i in range(1, x):
		result *= i
	return result
a = int(input('please input a number'))		#这里int最好加上
b = quant(a)
print("%d 的阶乘是 %d" % (a, b))	#这里中间没有逗号！！

12 的阶乘是 479001600

递归效率比较低

28.	还是递归，做斐波那契
非递归版本：
a = []
def quant(n):
    n1 = 1
    n2 = 1
    n3 = 1
    a.append(n1)
    a.append(n2)
    if n < 1:
        print('ERROR')
        return -1
    while (n - 2) > 0:
        n3 = n1 + n2		#这里仅仅是把每一个值做了交替！
        n1 = n2
        n2 = n3
        n = n - 1
        a.append(n3)
    return n3

result= quant(10)
if result != -1:
    print('一共%d只兔子诞生'%result)

输出结果是：一共55只兔子诞生
a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

递归版本：		#原理是5分为4和3相加，4分为3和2相加
def feb(n):
    if n < 1:
        print("error")
        return -1
    if n == 1 or n == 2:
        return 1
    else:
        return feb(n - 1) + feb(n - 2)

result = feb(10)
print(result)

29.	汉诺塔做递归
b = 0
def hannoi(n, x, y, z):	#xyz是三根针，相当于被移动位，辅助移动位，目标位
	global b
	if n == 1:
		b = b + 1
		print(x, "-->", z)	#一个片，x直接到z
	else:
		b = b + 1
		hannoi(n - 1, x, z, y)	#将前n-1个盘子从x移动到y上
		print(x, "-->", z)		#将最底下的盘子从x移动到z上
		hannoi(n - 1, y, x, z)	#将y上的n-1个盘子移动到z上
a = int(input('请输入层数'))
hannoi(a, "X", "Y", "Z")
打印共执行了多少次，就直接b即可。

30.	字典：
	字典是映射
	一个最基本的调用映射的方法：
	a = ['A', 'B', 'C', 'D']
	b = ['E', 'F', 'H', 'G']
	这两个是互相对应的，所以打印b的G可以用a来这么做：
	print(b[a.index('D')])
	
	用字典的方式解决：
	dic1 = {'A': 'E', 'B': 'F', 'C':'H', 'D':'G'}	#大括号就是字典！有很多键值组和
	print('口号是', dic1['D'])
	
	dict就是字典函数dict(mapping)，注意这里dict的参数只有1个！只能是映射！所以可以将元组伪装成1个参数来赋值进去
	可以这样：
	dic1 = dict(((1, 'A'), (2, 'b'), (3, 'C'), (4, 'D'), (5, 'E')))
	dic1输出是：{1: 'A', 2: 'b', 3: 'C', 4: 'D', 5: 'E'}
	
	也可以这样：
	dic2 = dict(a1 = 'A', a2 = 'B')		#!!!这里一定注意，左边可以是中文，但是一定不能加引号！！这是关键字类型！！
	dic2 = {'a1': 'A', 'a2': 'B'}
	
	dict如果输入了{}里面没有的值，则自动加进去新值，如果输入了原本就有的值，则做一次修改
	dic2 = {'a1': 'A', 'a2': 'B'}
	dic2['c1'] = 123		#这里键值都要加引号，如果是关键字的话。
	dic2['a1'] = 'KKK'
	
	此时dic2 = {'a1': 'KKK', 'a2': 'B', 'c1': 123}
	
31.	字典其他用法：
	fromkeys(S[,V])	#创建s:v，v默认是none
	创建新的字典
	
dic1 = {}
dic1 = dic1.fromkeys((1, 2, 3))	#双括号！#且同时这里一定要赋值更新！不然等下输出dic1的时候还是{}！

dic1 = {1: None, 2: None, 3: None}
这里V只能有一个元素！
比如：
dic1 = {}
dic1 = dic1.fromkeys((1, 2, 3), ('one', 'two', 'three'))
dic1 = {1: ('one', 'two', 'three'), 2: ('one', 'two', 'three'), 3: ('one', 'two', 'three')}

dic1 = {}
dic1.fromkeys(range(10), '赞') = {0: '赞', 1: '赞', 2: '赞', 3: '赞', 4: '赞', 5: '赞', 6: '赞', 7: '赞', 8: '赞', 9: '赞'}

keys代表键，如果想把键都打印出来，则：
for eachkey in dic1.keys():			#.keys()
	print(eachkey)
	
结果：
0
1
2
3
4
5
6
7
8
9

values()代表值，同理：
for eachvalue in dic1.values():
	print(eachvalue)
	
#outcome:	
赞
赞
赞
赞
赞
赞
赞
赞
赞
赞

items()表示项，把每一项都打印出来:
for eachitem in dic1.items():
	print(eachvitem)
结果：
(0, '赞')
(1, '赞')
(2, '赞')
(3, '赞')
(4, '赞')
(5, '赞')
(6, '赞')
(7, '赞')
(8, '赞')
(9, '赞')

dic1[31] = '赞'

get()方法，减少报错，尤其是调用不存在的值的时候
dic1.get(32)这就什么都不会返回，因为32个不存在，print出来时None

也可以返回默认值，比如dic1.get(32, '没有这个数！')

dic1.get(5) = '赞',会返回

更快速的办法判断键是否在字典里面，可以用 
30 in dic1
返回True就是在里面
注意这个in 或者not in不能用于值，只能用于键！


如果需要清空字典，推荐用.clear()而不是直接a = {}
因为如果项目复杂，中间有b = a这种情况，
那么当你a.clear()之后b也会clear掉。但如果仅赋值a = {}
b依然储存了数据。这对隐私数据存储很不好

同理一个copy()方法
a = {1:"A", 2:"B", 3:"C"}
b = a
c = a.copy()
此时通过id()查询一下abc，有：
>>> id(a)
2446169078104
>>> id(b)
2446169078104
>>> id(c)
2446169591880
c是自己复制了一份，所以跟ab没有关系，以后在改变c的话ab不会改变，但是改变b的话a会跟着改变，改变a的话b也会改变！


pop():弹出键的值
popitem():弹出项
a = {1:"A", 2:"B", 3:"C"}
a.pop(2) = 'B'
a = {1: 'A', 3: 'C'}	#B就不见了

pop的话在数组中都是自动弹出最后一个
a = {1:"A", 2:"B", 3:"C"}
a.popitem() = (3, 'C')
a = {1: 'A', 2: 'B'}


a.setdefault('小白', 1)
a = {1: 'A', 2: 'B', '小白': 1}
没有创建的会自动创建。创建了的会更改值。

update()
b = {'小黑': 1, '小白': 2}
a.update(b)
a = {1: 'A', 2: 'B', '小白': 2, '小黑': 1}
相当于列表的extend。


32.	集合：set
	a = {1, 2, 3, 4, 5}
	没有映射的关系的话，用大括号括起来就是集合
	
	集合直接会把重复的元素剔除掉！
	集合没有顺序，不支持索引！
	不能a[2]这样！
	
	set()创建集合
	set1 = set([1, 2, 3, 4, 5, 5, 4])
	set1 = {1, 2, 3, 4, 5}
	
	去除重复元素简单方法：
	num1 = list(set(num1))
	#但是这样是不能保证原来的顺序！！！
	
	集合也可以用in not in来访问
	add(), remove()
	集合只能用add()来添加元素！
	set1.add(123)
	set1.remove(234)
	
	
	不可变集合：frozenset
	a = frozenset([1, 2, 3, 4, 5])
	a.add(11)	#这里会报错，因为不能添加！
	
33.	用python来进行打开文件的操作:
	open()
	不同的打开模式：
	'r':只读方式
	'w':写入文件，会覆盖已存在的文件
	'x':如果文件已经存在，使用此模式打开会发生异常
	'a':以写入模式打开，如果文件存在，则在末尾追加
	'b':二进制模式打开
	't':文本模式打开
	'+':可读写模式，可以添加到其他模式中
	如果打开一个不存在的文件，则必须是w才能创建新文件
	默认是r和t
	
	
	f = open('C:\\Users\\handsomevictor\\Desktop\\股票相关\\2020.8.17.txt')
	这里一定要用引号引起来！！！
	
	文件执行操作：
	f.close()关闭文件
	f.read(size = -1)读取size个字符，当为给定或者size是负数时候，读取剩余所有字符，然后作为字符串返回
	f.readline()以写入模式打开，如果文件存在则在末尾追加写入
	f.write(str)将字符串写入文件
	f.writelines(seq)像文件写入字符串序列seq
	f.seek(offset, from)在文件中移动指针，从from(0代表起始位置，1代表当前位置，2代表文件末尾)偏移offset个字节
	f.tell()返回当前在文件中的位置
	
	注意，使用完文件要记住close()不然可能不会自动保存
	
	f = open('C:\\Users\\handsomevictor\\Desktop\\股票相关\\2020.8.17.txt', 'r',encoding='UTF-8')
	注意实际操作中，一定要加'r'和后面的UTF-8，不然中文的显示不出来
	
	注意！这是我一点一点摸索的！
	f.read()完了之后，指针是会到最后一个位置的！
	f.的这以上的所有操作，只要涉及读取，读完之后都会改变指针位置的。
	所以需要将指针复位。
	f.seek(0,0)，这样就从0点开始复位了。
	想知道现在指针在哪里，直接就f.tell()即可
	
	a = list(f)的话，会自动的把每一行转变为一个数组中的元素
	但是要注意，这里list(f)只会从指针在f中的位置开始到结尾。
	
	需要将list中的打印出来，效率高：
	for each_line in f:
		print(each_line)
	（这样会原本换行的会又换一次行）
	
	！！！！！！！！！！！！！！！！！！！
	文件的写入：
	确保已经是'w'或者'a'
	直接f.write('\nwerwerwer')就会直接添加到末尾
	但是要注意，这个时候一定要f.close()
	否则不会直接保存，不能直接f.read()
	另外，下一次f.read()之前，一定要确保open的时候里面是a+或者w+，不然是不可以read的！！！！！
	
34.	将文件中的数据进行分割等。
	比如有txt文件是这样内容：
A:the first line
B:the second line
A:the third line
-----------
C:the fourth lineasdasdasd
-------
D:i dont like yuou
E:my stock price is 12000
	
	按照---进行分割，然后单独储存成txt
	
	这是个失败的举例。。详见66.py
	
35.	模块
	Operating System模块
	这个是让py在不同的环境中都能适用的一个方法
	
>>> import os		#先import
>>> os.getcwd()
'C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\Python37_64'
	返回当前工作目录，py的安装地方
	
os.chdir('C:\\Users\\handsomevictor\\Desktop\\python IDLE')	改变当前目录
os.listdir()		列举所在路径中的文件名，列举之后是以数组的形式存在！！
os.mkdir('C:\\Users\\handsomevictor\\Desktop\\python IDLE\\A')				创建文件夹！只能是文件夹，不能是文件！
os.remove('C:\\Users\\handsomevictor\\Desktop\\python IDLE\\A\\a.txt')		删除文件！不能是目录！！
os.rmdir('C:\\Users\\handsomevictor\\Desktop\\python IDLE\\A')				删除目录！如果目录中有内容则无法直接删除全部目录
os.removedirs()	递归删除目录，从子目录到父目录尝试逐层删除，除非遇到非空抛出异常
os.rename(old, new)	重新命名

os.system('cmd')	os.system()括号里加上windows shell里面的命令即可，比如mspaint，calc

os.curdir	这不是函数，这个指代当前目录，相当于'.'
用法：获取当前目录下的文件内容：os.listdir(os.curdir) (这个等同于os.listdir('.')，但是更规范，不容易错
os.pardir	指代上一级目录，相当于'..'


os.path方法，里面有挺多平常用不到的但是在大规模数据里面能用到的方法。。
os.path.basename(r'C:\Users\handsomevictor\Desktop\python IDLE\第一个小游戏.py')	#返回的是去掉路径之后的纯文件名
	这个返回的就是：'第一个小游戏.py'
os.path.dirname(r'C:\Users\handsomevictor\Desktop\python IDLE\第一个小游戏.py')		#返回的是路径名，去掉文件名
	这个返回的就是：'C:\\Users\\handsomevictor\\Desktop\\python IDLE'
	这个返回的路径可以配合listdir来直接提取当前目录下其他文件
	
os.path.join()	#是组成路径的方法，但是如果要加上盘符，则需要加\\，比如：
	os.path.join('C:\\', 'A', 'B') = 'C:\\A\\B'
	os.path.join('A', 'B', 'C') = 'A\\B\\C'
	
os.path.split('')	#这个split是会将路径分成路径和文件名两部分的，但是注意如果只是纯路径，则也会将最后一部分文件名单独分割出来
	os.path.split('C:\\A\\B\\C\\D\\sexy.avi') = ('C:\\A\\B\\C\\D', 'sexy.avi')
	os.path.split('C:\\A\\B\\C\\D') = ('C:\\A\\B\\C', 'D')
	os.path.splitext('C:\\A\\B\\C\\D\\sexy.avi') = ('C:\\A\\B\\C\\D\\sexy', '.avi')
		这里用到搜索文件类型里面还是很好用的，比如a = list(os.path.splitext()), b[1]就能返回这个后缀名
os.path.getsize(file)	#返回尺寸
os.path.getatime(file)	#返回这个文件的最近访问时间
os.path.getctime(file)	#返回这个文件的最近创建时间
os.path.getmtime(file)	#返回这个文件的最近修改时间
	这三个可用time模块的gmtime()或者localtime()来换算！gm是返回格林尼治时间，localtime是返回当地时间！
	import time
	a = time.gmtime(os.path.getatime())
		会返回一个这种玩意：time.struct_time(tm_year=2020, tm_mon=8, tm_mday=10, tm_hour=4, tm_min=25, tm_sec=35, tm_wday=0, tm_yday=223, tm_isdst=0)
		想调用的话直接：a.tm_year = 2020就行了

os.path.exists(path)	判断路径或文件是否存在
os.path.isabs(path)		判断路径是否为绝对路径
isdir 
isfile
islink
samefile(path, path)	判断两个路径是否指向同一个文件

36. 将列表，字典等转化为二进制文件，就可以很好的做转变
	pickle模块

import pickle
my_list = [1, 2, 3, 3.45, [111, 455]]	#这里希望把这个列表保存成文件，永久保存
pickle_file = open('my_list.pkl', 'wb')		#这里一定要wb,写入+二进制
pickle.dump(my_list, pickle_file)			#这个是将文本输入进去
pickle_file.close()							#这个关闭一定要记得写！不然保存不了！
这样运行完就直接创建了my_list.pkl			#这里这个pkl文件不能用txt打开，因为打不开，是二进制

读取：load
pickle_file = open('my_list.pkl', 'rb')		#rb是读取二进制文件
my_list2 = pickle.load(pickle_file)			#load(file_name)，此时这个my_list2已经是原本的my_list了！就是数组！
print(my_list2)
#这样就可以读出来了


37.	异常处理：
	在出现异常的时候利用Py内部机制来直接处理掉
	
	AssertionError	断言语句（assert）失败	#使用assert方法判断的时候失败
	AttributeError	尝试访问未知的对象属性
	
	记住也可以用.get()来访问字典中不存在的key，因为什么都不会返回
	
38.	try语句，任何在try里面出现的异常都会被检测到，然后根据你的想法来进行操作
	
try:
	sum = 1 + '1'						#TypeError类型
	a = open('why am i a txt file')		#文件是不存在的
	print(a.read())
except OSError as reason:
	print('your file does not exist!' + str(reason))	#这样的话用户体验很好	#一定要把reason给str了！
except TypeError as reason:
	print('the sum you typed is not matching the type!' + str(reason))
finally:								#无论如何都会执行以下代码，无论错不错都应该执行的
	#一般finally在写入文件的操作中都会加入.close()


	1.这样的输出结果是：your file does not exist![Errno 2] No such file or directory: 'why am i a txt file'
	2.输出结果: the sum you typed is not matching the type!unsupported operand type(s) for +: 'int' and 'str'
	注意一下，如果是sum在前则只会返回第二个typeerror类型！
	
	try语句一旦检测到异常，则剩下的语句不会执行的！！！除非加入了finally，但加入了finally也是从错误到finally中间不会执行

也可以一起写:
	except (OSError, TypeError):
	
39.	else其他功能
	else和while
	while XX:
		if...
		break
	else:
		XX...
	
	这里else就是当while里面的每一个都不成执行的时候才会去执行
	
	for语句类似
	
	
	try也可以加入else！
try:
	int('abc')
except ValueError as reason:
	print('wrong!' + str(reason))
else:
	print('no problem!')
意思是当except不执行的时候就会执行下面的else!

40. with语句
	不用考虑文件关闭的问题
	
try:
	with open('test.txt', 'w') as f:		#这里with开头的话，就不需要考虑最后的创建文件之后的关闭问题了！
	for each_line in f:
		print(each_line)
except OSError as reason:
	print('error!' + str(reason))


41.	图形用户界面入门:GUI		#这里安装easygui的时候有小插曲！明明安装成功，但是却不能idle里面import！这是因为idle的版本和python的版本不一致!!!
	import easygui
	easygui.msgbox('i loe yuou ')
	
	也可以from easygui import *	#但是这样会覆盖同名的方法！
	那这样的话就可以直接写：msgbox('')了！！
	
	from easygui import as g
	
easygui的一个小项目:
import easygui as g
import sys

while 1:
	g.msgbox('welcome to the world of victor')
	msg = 'which girl do you want?'
	title = 'choose a girl'
	choices = ['grace', 'shirley', 'winnie']
	
	choice = g.choicebox(msg, title, choices)
	
	g.msgbox('your choice is ' + str(choice))
	
	msg = 'want to play it more?'
	title = 'please choose'
	
	if g.ccbox(msg, title):
	    pass		#user choose continue
	else:
        g.msgbox('huh, you dont want girl right?')
	    sys.exit(0)

注意：如果idle上运行不了easygui，那就换个编辑器就行了！

42. easygui整体介绍和用法：
	

